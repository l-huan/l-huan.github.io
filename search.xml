<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/07/30/%E6%9A%91%E6%9C%9F%E5%8C%97%E4%B8%8A/"/>
      <url>/2019/07/30/%E6%9A%91%E6%9C%9F%E5%8C%97%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="暑期北上"><a href="#暑期北上" class="headerlink" title="暑期北上"></a>暑期北上</h1><h2 id="北京四日"><a href="#北京四日" class="headerlink" title="北京四日"></a>北京四日</h2><p> <strong>住宿</strong>：广渠门外大街甲13号楼</p><h3 id="计划及候选景点（含注意事项及攻略）"><a href="#计划及候选景点（含注意事项及攻略）" class="headerlink" title="计划及候选景点（含注意事项及攻略）"></a>计划及候选景点（含注意事项及攻略）</h3><h5 id="天安门广场"><a href="#天安门广场" class="headerlink" title="天安门广场"></a>天安门广场</h5><ul><li><strong>门票</strong>：免费</li><li><strong>注意事项</strong>：安检、防晒</li><li><strong>攻略</strong>：地铁一号线 （天安门东站D口）下车</li></ul><h5 id="毛主席纪念堂"><a href="#毛主席纪念堂" class="headerlink" title="毛主席纪念堂"></a>毛主席纪念堂</h5><ul><li><p><strong>门票</strong>：免费</p></li><li><p><strong>注意事项</strong>：安检入场。注意衣着整洁、得体，脱帽瞻仰。穿背心、拖鞋者谢绝入内。</p><ul><li><blockquote><p><strong>全年星期二至星期日 8:00—12:00</strong>，其中7月1日至8月31日7:00—11:00，9月9日（毛泽东同志逝世纪念日）、12月26日（毛泽东同志诞辰纪念日）开放时间8:00—11:30，14:00—16:00.国家法定节假日、有关纪念日、天安门广场有活动另行通知。</p></blockquote></li></ul></li><li><p><strong>服务号及网站</strong>：<a href="http://cpc.people.com.cn/GB/143527/143528/index.html" target="_blank" rel="noopener">官网</a>    </p></li></ul><h5 id="天安门城楼"><a href="#天安门城楼" class="headerlink" title="天安门城楼"></a>天安门城楼</h5><ul><li><strong>门票</strong>：成人票15元；学生、60-65岁老人凭证5元</li><li><strong>注意事项</strong>：安门城楼内部整体维修，具体开放时间未定</li></ul><h5 id="故宫博物院"><a href="#故宫博物院" class="headerlink" title="故宫博物院"></a>故宫博物院</h5><ul><li><p><strong>门票</strong>：旺季联票60+10+10=80; 学生半价  <strong>提前网络购票，刷身份证进。</strong></p></li><li><p><strong>注意事项</strong>：禁烟、禁止闪光灯</p><ul><li>开馆时间8:30;   停止入馆时间16:10</li><li>故宫博物院实行自南向北单向参观路线：午门（南门）只作为参观入口，观众一律从午门进入故宫；神武门（北门）只作为参观出口，观众参观结束后可由神武门或东华门（东门）离开故宫。</li></ul></li><li><p><strong>服务号及网站</strong>：<a href="https://www.dpm.org.cn/Home.html" target="_blank" rel="noopener">官网</a>   玩转故宫小程序</p></li><li><p><strong>攻略</strong>：玩转故宫小程序纳凉线路或官网半日推荐线路</p><ul><li><ol><li>午门 2. 武英殿  3. 太和门  4. 太和殿  5. 中和殿  6. 保和殿  7.乾清宫  8. 交泰殿  9. 坤宁宫  10. 东六宫区  11. 斋宫  12. 宁寿宫区前朝（珍宝馆）13. 宁寿宫区后寝（珍宝、戏曲二馆和珍妃井）14. 神武门</li></ol><p><img src="暑期北上.assets/半日游推荐路线2.jpg" alt></p></li></ul></li></ul><h5 id="故宫端门数字博物馆"><a href="#故宫端门数字博物馆" class="headerlink" title="故宫端门数字博物馆"></a>故宫端门数字博物馆</h5><ul><li><strong>门票</strong>：</li><li><strong>注意事项</strong>：故宫博物院端门数字馆于2019年7月2日（周二）起进行设备维护，暂停开放。重新开放时间请关注故宫博物院官方网站通知。</li></ul><h5 id="景山公园"><a href="#景山公园" class="headerlink" title="景山公园"></a>景山公园</h5><ul><li><strong>门票</strong>：两元（<strong>畅游公园公众号购票，刷电子票入园</strong>）</li><li><strong>注意事项</strong>：开放时间6:30-21:00</li><li><strong>服务号及网站</strong>：畅游公园公众号（购票及攻略）</li><li><strong>攻略</strong>：</li></ul><h5 id="慕田峪长城"><a href="#慕田峪长城" class="headerlink" title="慕田峪长城"></a>慕田峪长城</h5><ul><li><strong>门票</strong>：报团</li></ul><h5 id="颐和园"><a href="#颐和园" class="headerlink" title="颐和园"></a>颐和园</h5><ul><li><p><strong>门票</strong>：颐和园联票旺季60元/张   学生半价。(联票包括门票和园中园门票 （园中园包括文昌院、德和园、佛香阁和苏州街）)    （<strong>畅游公园公众号购票，刷电子票入园</strong>）</p></li><li><p><strong>注意事项</strong>：大门开放时间：7:00—17:00； 园中园开放时间：9:00—16:00； 静园时间：19:00</p></li><li><p><strong>服务号及网站</strong>：<a href="http://www.summerpalace-china.com/index.html" target="_blank" rel="noopener">官网</a>   畅游公园公众号（购票及攻略）</p></li><li><p><strong>攻略</strong>：</p><ul><li>北宫门进，进去以后先爬10分钟的万寿山，到达佛香阁，到达顶峰后一览众山下，昆明湖在脚下一览无遗</li></ul><p><img src="暑期北上.assets/颐和园.jpg" alt></p></li></ul><h5 id="天坛公园"><a href="#天坛公园" class="headerlink" title="天坛公园"></a>天坛公园</h5><ul><li><p><strong>门票</strong>：旺季:(每年4月1日至当年10月31日) 门票：15元，优惠票：7.5元 ；联票：34元，优惠票：17元</p><ul><li>景点：<br>联票：20元，优惠票：10元<br>神乐署门票：10元，优惠票：5元，月票：15元<br>北神厨、北宰牲亭、斋宫门票凭本人身份证在相应门票兑换处换票进入。<br>北神厨、北宰牲亭单日限流5000人,斋宫单日限流3000人。</li></ul></li><li><p><strong>注意事项：</strong></p><ul><li>公园大门：旺季开放时间：6:00-21:00 ； 静园时间：22点</li><li>景点：（含祈年殿、回音壁、圜丘、神乐署）开放时间：8:00-17:00 </li><li>北神厨、北宰牲亭、斋宫：开放时间：每周二至周日上午9:00—12:00 下午13:00—16:00</li></ul></li><li><strong>服务号及网站</strong>：<a href="http://www.tiantanpark.com/" target="_blank" rel="noopener">官网</a>   畅游公园公众号（购票及攻略）</li><li><strong>攻略：</strong></li></ul><h5 id="鸟巢-amp-水立方"><a href="#鸟巢-amp-水立方" class="headerlink" title="鸟巢&amp;水立方"></a>鸟巢&amp;水立方</h5><ul><li><p><strong>门票：</strong></p><ul><li>鸟巢：普通票:50人民币；空中走廊联票:80人民币；学生半价优惠；开放时间 09:00-19:00 (3月7日-10月31日 周一-周日)</li><li>水立方：成人票:30人民币 ； 学生半票；开放时间：09:00-18:00 (1月1日-12月31日 周一-周日)</li></ul></li><li><p><strong>攻略</strong>：夜景，选择性购票进馆游览</p></li></ul><h3 id="具体安排"><a href="#具体安排" class="headerlink" title="具体安排"></a>具体安排</h3><iframe src="http://www.ldmap.net/map.html?id=79f0bc00-f5f6-4f01-8c7c-da085c8d0425&iframe=true" height="722" width="1519"></iframe><h4 id="day1-八月四号"><a href="#day1-八月四号" class="headerlink" title="day1-八月四号"></a>day1-八月四号</h4><ul><li><p>机场 - 民宿 ：</p><blockquote><p><strong>机场线（T2航站楼站(D口)上，三元桥站下，1站），换地铁10号线（三元桥站上，双井站下，7站），下车步行980米，约1小时5分钟</strong></p></blockquote></li><li><p>午饭&amp;下午购物：</p><ul><li>候选商圈：<ol><li>三里屯太古里</li><li></li></ol></li></ul></li></ul><ul><li><p>待选景点(观光)：</p><ol><li><a href="#颐和园">颐和园</a></li></ol></li></ul><ul><li><p>晚上：</p><ol><li>世纪天阶（夜景）</li><li>国贸大厦（夜景）</li><li><a href="#鸟巢&amp;水立方">鸟巢&amp;水立方</a>（夜景）</li></ol></li><li><p><a href="#慕田峪长城">慕田峪长城</a> 一日团（民宿接，含午餐）-  北京胡同 - 后海（散团）</p></li><li><p>晚饭：后海酒吧一条街或民宿</p></li><li><p>夜景：</p><ol><li>世纪天阶（夜景）</li><li>国贸大厦（夜景）</li><li>大裤衩（中央广播电视总台）</li></ol></li></ul><h4 id="day3-八月六号"><a href="#day3-八月六号" class="headerlink" title="day3-八月六号"></a>day3-八月六号</h4><ul><li><a href="#天安门广场">天安门广场</a> 周边（人民大会堂、首都博物馆） - <a href="#毛主席纪念堂">毛主席纪念堂</a> </li><li>午饭候选：四季民福烤鸭店</li><li>下午：<a href="#故宫博物院">故宫博物院</a> - <a href="景山公园">景山公园</a> （俯瞰故宫）</li><li><p>晚上：（灵活安排）民宿晚饭、观夜景：</p><ol><li>国家大剧院</li></ol></li></ul><h4 id="day4-八月七号"><a href="#day4-八月七号" class="headerlink" title="day4-八月七号"></a>day4-八月七号</h4><ul><li><p>民宿 - 北京站（寄存行李）</p><blockquote><p><strong>地铁7号线（广渠门外站(B口)上，磁器口站下，2站），换地铁5号线（磁器口站上，崇文门站下，1站），换地铁2号线（崇文门站上，北京站下，1站）约38分钟</strong></p></blockquote></li><li><p><a href="#天坛公园">天坛公园</a></p></li><li><p>中午：待定</p></li><li><p>下午：修整–前往北戴河（下午三点左右或六点动车）</p></li></ul><h2 id="北戴河慢游三日"><a href="#北戴河慢游三日" class="headerlink" title="北戴河慢游三日"></a>北戴河慢游三日</h2><iframe src="http://www.ldmap.net/map.html?id=3df0fd22-05e4-4991-9602-3bd7a791025c&iframe=true" height="722" width="1519"></iframe><h4 id="day0-八月七号"><a href="#day0-八月七号" class="headerlink" title="day0-八月七号"></a>day0-八月七号</h4><ul><li>傍晚或晚上抵达 - 民宿</li><li>晚霞余晖</li></ul><h4 id="day1-八月八号"><a href="#day1-八月八号" class="headerlink" title="day1-八月八号"></a>day1-八月八号</h4><ul><li>鸽子窝公园</li><li>滨海栈道-东海滩-奥林匹克公园</li><li>中午民宿修整</li><li>碧螺湾酒吧公园（晚上演出）</li></ul><h4 id="day2-八月九号"><a href="#day2-八月九号" class="headerlink" title="day2-八月九号"></a>day2-八月九号</h4><ul><li>联峰山公园</li><li>午餐  中意蒸汽海鲜赶海餐厅</li><li>老虎石公园</li><li>刘庄夜市</li><li>怪楼奇园–俄罗斯风情屋</li></ul><h4 id="day3-八月十号"><a href="#day3-八月十号" class="headerlink" title="day3-八月十号"></a>day3-八月十号</h4><ul><li>南戴河仙螺岛或求仙入海处</li><li>下午回程—京唐港</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-字典&amp;集合</title>
      <link href="/2019/01/22/python-%E5%AD%97%E5%85%B8&amp;%E9%9B%86%E5%90%88/"/>
      <url>/2019/01/22/python-%E5%AD%97%E5%85%B8&amp;%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><blockquote><p>无序键值对序列,字典中的‘键’可以是python中任意不可变数据（如整数、实数、复数、字符串、元组）<em>键不能重复，值可以相同</em></p></blockquote><ul><li>当字典对象进行迭代时，默认是对键进行迭代，可以通过.items() .values()指定迭代对象</li></ul><ol><li>字典的创建、添加、修改、删除</li></ol><blockquote><p>dict还支持字典推导式创建</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>访问字典对象的数据</li></ol><hr><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ol><li>集合基本知识</li></ol><blockquote><p>集合是无序可变序列，集合中的元素不可重复。集合中的元素只能是不可变的数据类型（或者说可哈希的），如数字、元组、字符串。 </p></blockquote><blockquote><p>集合也支持集合推导式</p></blockquote><ol><li>集合基本操作及运算</li></ol><blockquote><p>集合的一个重要应用就是去重</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象</title>
      <link href="/2019/01/21/python%E7%B1%BB/"/>
      <url>/2019/01/21/python%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><hr><h4 id="一、类的定义与使用"><a href="#一、类的定义与使用" class="headerlink" title="一、类的定义与使用"></a>一、类的定义与使用</h4><ul><li><p>关键字 class 。类的成员包括==数据成员==和==成员方法==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名[(基类名1，基类名2···)]:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    注释说明 #可以通过 类名.__doc__查看</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    数据成员和成员方法定义</span><br></pre></td></tr></table></figure></li><li><p><strong>私有成员&amp;公有成员</strong></p></li></ul><blockquote><p><strong>这里讲的成员包括数据成员和成员方法</strong> <br>在python中并没有私有成员的访问保护机制，换句话说<em>python中不存在严格意义上的私有成员</em>。</p></blockquote><p>在python中通过下划线来区分私有成员、保护成员和公有成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) __xxx__   系统定义的特殊成员</span><br><span class="line">(2) __XXX     私有成员，一般只在类的内部访问或通过非私有的成员方法进行访问。</span><br><span class="line">              或者通过特殊方法“对象名._类名__xxx”访问</span><br><span class="line">(3) _xxx      保护成员，不能用from module import *导入，只有类对象(实例)和子类对象可以访问</span><br></pre></td></tr></table></figure></p><ul><li><strong>数据成员</strong></li></ul><p>数据成员除了按私有和公有分之外，还可以分成==属于对象的==和==属于类的==</p><blockquote><p>属于对象的数据成员一般在<strong>init</strong>(self，···)函数中定义，且<strong>一定要加self.前缀</strong>。<br>同一类的不同对象(实例)之间的数据成员互不影响；属于类的数据成员在该类所有对象之间共享。</p></blockquote><ul><li><strong>成员方法</strong></li></ul><p>成员方法大致可分为<strong>公有方法</strong>、<strong>私有方法</strong>、<strong>静态方法</strong>、<strong>类方法</strong>。其中公有方法和私有方法统称为实例方法（可以理解为属于对象的）。这两类方法可以访问类成员和对象成员；而静态方法和类方法只能访问属于类的成员（类成员），且定义时需要用@staticmethod、@classmethod修饰器来声明。可以通过类或者对象两种方式调用静态方法和类方法，而只能通过对象来调用实例对象（私有方法还不能直接调用，而是通过python提供的特殊方式“对象名._类名__成员名”来调用 [不建议这么做]）。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python入门</title>
      <link href="/2019/01/21/python%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/21/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>python基础（基于值的内存管理）（一切都是对象）</p><ul><li>内置函数</li><li>人机交互基本函数（文件操作）</li></ul><hr><h2 id="一、python基础"><a href="#一、python基础" class="headerlink" title="一、python基础"></a>一、python基础</h2><ol><li><p>在python中不需要事先声明变量及变量类型，但python仍是强类型语言，只是它会根据变量的赋值自动给出类型；而且python中变量的类型可以随时改变（这跟python的基于值的内存管理方式的设计密切相关）。</p><ul><li><p>基于值的内存管理方式：</p><blockquote><p>如果不同变量的值相同，这个值在内存中只有一份，多个变量指向同一块内存单元</p><blockquote><p>id(变量名)可以查看变量所指的内存空间的地址</p></blockquote></blockquote><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=1</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2008532720</span><br><span class="line">&gt;&gt;&gt; y=x</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2008532720</span><br><span class="line">&gt;&gt;&gt; y+=6</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2008532912</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>python变量不直接存储值，而是存储对象的引用</p><blockquote><p>python具有自动内存管理功能，即当内存空间里的一个值没有变量指向是会被自动删除。而del命令只是手动删除不再使用的变量，并不会释放内存空间。</p></blockquote></blockquote></li></ul></li></ol><h2 id="二、内置函数（BIF）built-in-function"><a href="#二、内置函数（BIF）built-in-function" class="headerlink" title="二、内置函数（BIF）built-in function"></a>二、内置函数（BIF）built-in function</h2><ol><li>使用技巧</li></ol><ul><li>使用dir(__builtins__)列出所有内置对象和内置函数（dir()本身就是一个常用的内置函数）</li><li>使用help(函数名)查看函数帮助信息</li><li>使用help(‘modules’)查看本机所有可用模块</li></ul><ol start="2"><li>常见实用BIF</li></ol><table><thead><tr><th>内置函数</th><th>使用说明</th></tr></thead><tbody><tr><td>dir(obj)</td><td>返回指定对象obj或模块obj的成员列表</td></tr><tr><td>help()</td><td>返回帮助信息</td></tr><tr><td>id(x)</td><td>返回变量x所引用的内存空间的地址</td></tr><tr><td>bool(x)</td><td>返回x的值所对应的布尔值true或false</td></tr><tr><td>all(iterable)</td><td>如果可迭代对象iterable所有元素x都有bool(x)=true,<br>则返回true。对于空的迭代对象也返回true</td></tr><tr><td>any(iterable)</td><td>类比all()的用法</td></tr><tr><td>chr(num)</td><td>返回Unicode编码为num的字符</td></tr><tr><td>ord(x)</td><td>返回字符x的Unicode编码</td></tr><tr><td>int(x [,d])</td><td>将浮点数x去尾转化为整数或者将d进制串转化为十进制整数</td></tr><tr><td>oct(x)</td><td>将十进制整数数x转化为八进制串</td></tr><tr><td>hex(x)</td><td>类比oct()</td></tr><tr><td>bin(x)</td><td>类比oct()</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(3.6)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; x=2.365;</span><br><span class="line">&gt;&gt;&gt; int(x)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; int(&apos;1011001&apos;,2)</span><br><span class="line">89</span><br><span class="line">&gt;&gt;&gt; int(&apos;145&apos;,8)</span><br><span class="line">101</span><br><span class="line">&gt;&gt;&gt; int(&apos;4E&apos;,16)</span><br><span class="line">78</span><br><span class="line">&gt;&gt;&gt; bin(10)</span><br><span class="line">&apos;0b1010&apos;</span><br><span class="line">&gt;&gt;&gt; oct(10)</span><br><span class="line">&apos;0o12&apos;</span><br><span class="line">&gt;&gt;&gt; hex(10)</span><br><span class="line">&apos;0xa&apos;</span><br></pre></td></tr></table></figure><table><thead><tr><th>内置函数</th><th>使用说明  </th></tr></thead><tbody><tr><td>round(x [,小数位数])</td><td>四舍五入保留指定位数小数，不指定时返回整数</td></tr><tr><td>len(x)</td><td></td></tr><tr><td>sum(x)</td><td></td></tr><tr><td>max\min()</td><td></td></tr><tr><td>range([start,] end [,step])</td><td>返回range对象，默认起始值为0，步长为1</td></tr><tr><td>list([x]),set([x]),<br>tuple([x]),dict([x])</td><td>创建列表，集合，元组，字典</td></tr><tr><td>str(x)</td><td>返回对应转化后的字符串</td></tr><tr><td>type(obj)</td><td>返回对象obj的类型</td></tr><tr><td>isinstance(obj, class)</td><td>测试对象obj是否属于指定类型class</td></tr><tr><td>input([提示内容字符串])</td><td>接受键盘输入的内容，返回字符串</td></tr><tr><td>sorted(iterable [,key=None][,reverse=Flase])</td><td>返回排序后的列表。iterable表示列表或可迭代对象，key用来指定排序规则，reverse用来指定升序还是降序</td></tr><tr><td>eval(s)</td><td>返回表达式s（字符串）的值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=2</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; isinstance(x,int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(x,float)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; type(3.5)</span><br><span class="line">&lt;class &apos;float&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; range(10)</span><br><span class="line">range(0, 10)</span><br><span class="line">&gt;&gt;&gt; x = list(range(10))</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; str(x)</span><br><span class="line">&apos;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&apos;</span><br><span class="line">&gt;&gt;&gt; sorted(x,reverse=True)</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line">s = input(&apos;a formula:&apos;)</span><br><span class="line">a formula:3+9</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;3+9&apos;</span><br><span class="line">&gt;&gt;&gt; eval(s)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; s[0]</span><br><span class="line">&apos;3&apos;</span><br><span class="line">&gt;&gt;&gt; a = int(s[0])</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ol start="3"><li>说明</li></ol><ul><li>内置函数还有像map(),next(),reversed(),zip(),filter(),reduce()（==python3中reduce函数需从functools库导入==）等等。后序会进行使用说明。<h2 id="三、人机交互"><a href="#三、人机交互" class="headerlink" title="三、人机交互"></a>三、人机交互</h2></li><li><p>在人机交互时，input用来实现机器对人的输入的理解，print用来显示机器运算的结果。但应注意的是==input()函数无论键盘输入什么都当做字符串来处理==，常常配合eval()或其他内置函数转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = eval(input(&apos;please input an inter:&apos;))</span><br><span class="line">please input an inter:25</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; y = eval(input(&apos;please input an float:&apos;))</span><br><span class="line">please input an float:3.14</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">3.14</span><br><span class="line">&gt;&gt;&gt; s= input()</span><br><span class="line">3.56</span><br><span class="line">&gt;&gt;&gt; type(s)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; float(s)</span><br><span class="line">3.56</span><br></pre></td></tr></table></figure></li><li><p>print(value1[,value2…] [,sep =’ ‘] [,end = ‘\n’] [,file = sys.stdout] [flush = False])</p><blockquote><p>sep表示当有多个输出值时，各个值之间的分隔符，默认为空格<br>end表示print语句打印结束末尾的结束符，默认为换行符<br>file表示输出的位置，默认为标准输出设备<br>flush  ？</p></blockquote></li><li><p>python标准库sys还提供了read(),readline()方法从键盘读入指定数量字符</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python控制结构</title>
      <link href="/2019/01/21/python%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/01/21/python%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p>分支结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 表达式：</span><br><span class="line">    代码块</span><br><span class="line">（else:</span><br><span class="line">    代码块）</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">三元运算符if···else···</span><br><span class="line">例如：</span><br><span class="line">    x = 表达式1 if 条件表达式 else 表达式2</span><br><span class="line"></span><br><span class="line">三元运算符还支持嵌套</span><br></pre></td></tr></table></figure></li><li><p>循环结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 表达式：</span><br><span class="line">    循环体</span><br><span class="line">（else：</span><br><span class="line">    代码块）</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 可迭代对象：</span><br><span class="line">    循环体</span><br><span class="line">（else：</span><br><span class="line">    代码块）</span><br></pre></td></tr></table></figure><p>  ==else后的代码只在循环正常结束（自动到达终止条件）时才执行==，即通过break退出循环则不执行else代码块。</p></li></ul><hr><h3 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h3><ul><li><p>关于函数参数</p><blockquote><p><strong>python中一切皆是对象，所以函数调用参数传递都不是值传递，传递的都是对象的引用</strong><br>python还能通过序列解包进行函数参数的传递</p></blockquote><ol><li><p>默认值参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def func_name(parameter1,parameter2 = default_value···)</span><br><span class="line">    函数体</span><br><span class="line">注: 有默认值的参数不能出现在无默认值参数的左边</span><br></pre></td></tr></table></figure></li><li><p>关键参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def func_name(parameter1, parameter2, parameter3)</span><br><span class="line">    函数体</span><br><span class="line">    </span><br><span class="line">函数调用时参数传递可以指定</span><br><span class="line">func_name(parameter2=value2, parameter1=value1, parameter3=value3)</span><br></pre></td></tr></table></figure></li><li><p>可变长参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func_name(*parameter)</span><br><span class="line">    函数体</span><br><span class="line">函数调用时可以接受多个参数，并以元组形式传递给形参</span><br><span class="line"></span><br><span class="line">def func_name(**parameter)</span><br><span class="line">    函数体</span><br><span class="line">函数调用时可以接受多个参数，并以字典形式传递给形参</span><br></pre></td></tr></table></figure></li></ol></li><li><p>变量作用域</p></li></ul><blockquote><p>python引用同名变量的顺序：<br>当前作用域局部变量-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量.<br>更加专业的说法是LEGB规则：<br>本地作用域(local)-&gt;嵌套作用域(enclosing function locals)-&gt;全局作用域(global)-&gt;内置作用域(builtins)</p></blockquote><ol><li><strong>global</strong>关键字<ol><li>通过global关键字将外部已定义的变量声明为一个全局变量。此时在函数内对变量的修改是全局可见的。</li><li>通过global关键字在函数内部新定义一个变量，此变量是全局的，在函数外部也能引用。</li></ol></li><li><p><strong>nonlocal</strong>关键字</p><blockquote><p>nonlocal关键字用来定义或声明一个介于局部和全局之间的变量。一般用于函数嵌套定义里，内层函数声明一个具有嵌套作用域的变量（并非全局）。</p></blockquote></li></ol><ul><li><p>匿名函数（<strong>lambda表达式</strong>）</p><p>  形式：lambda [arg1 [,arg2,arg3···]]：表达式</p><blockquote><p>类似于带参数的宏定义，lambda表达式常用作sort函数的key参数。也支持关键参数，默认值参数。表达式中可以调用其他函数，其计算结果相当于函数返回值。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python序列模型</title>
      <link href="/2019/01/21/python%E5%BA%8F%E5%88%97/"/>
      <url>/2019/01/21/python%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="序列——-数据模型"><a href="#序列——-数据模型" class="headerlink" title="序列——-数据模型"></a>序列——-数据模型</h1><p>序列按存储元素类型是否一致可分为：<strong>扁平序列</strong>、<strong>容器序列</strong>。</p><ul><li><p>扁平序列：<strong>string(字符串)、array.array(数组)、memoryview(内存视图)、bytes(字节串)、bytearray(字节数组)</strong></p><blockquote><p>扁平序列中所有元素都为同类型数据。</p></blockquote></li><li><p>容器序列：<strong>list(列表)、tuple(元组)、collection.deque(双向队列)</strong></p><blockquote><p>容器序列则可以存储不同类型的数据，但容器序列实际存储的是个元素的引用。支持元素嵌套</p></blockquote></li></ul><p>序列按是否更改又能分为：<strong>可变和不可变序列</strong>。</p><ul><li>可变序列：<strong>list、array.array、bytearray、colloction.deque、memoryview</strong></li><li>不可变序列：<strong>tuple、string、bytes</strong></li></ul><p><strong>字典和集合严格意义上说并不属于序列。</strong>序列即为一系列数据元素有秩序的组合在一起，构成一个整体，是一种组织数据的模型。</p><blockquote><p>python中有序序列如list、tuple、str和range等都支持<strong>双向索引</strong><br>正向索引：从0开始<br>逆向索引：-1代表倒数第一个元素，-2代表代数第二个元素，以此类推</p></blockquote><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表为python内置的可变序列数据结构之一，包含若干==有序连续==的内存空间。</li></ul><blockquote><p>当列表增加或删除元素时，列表对象会自动进行内存的扩展或收缩，以保证元素之间没有缝隙。<br>由于在列表中间插入或删除元素时会涉及大量元素的移动，效率较低，因此尽量从尾部增删元素。<br>==*同一列表中的元素的数据类型可以各不相同==</p><blockquote><p>因为基于值的内存管理机制，列表中元素并不直接存储值，而是存储值的引用（或者说对象的引用）。</p></blockquote></blockquote><h4 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h4><ol><li>list()内置函数</li><li style="list-style: none"><input type="checkbox"> 操作符，各元素之间用逗号隔开</li></ol><h4 id="列表的基本操作"><a href="#列表的基本操作" class="headerlink" title="列表的基本操作"></a>列表的基本操作</h4><ol><li><strong>原地操作</strong>（通常都是list对象自带的行为操作，del命令删除指定位置元素）</li></ol><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>lst.append(x)</td><td>在列表lst末尾增加元素X</td></tr><tr><td>lst.extend(lst2)</td><td>在列表lst与lst2合并，==与lst+=lst2效果一样且都是原地操作.<br>但lst=lst+lst2则会改变lst的id值，即lst+lst2返回一个新的列表对象==</td></tr><tr><td>lst.insert(index,x)</td><td>在列表lst指定的index位置插入元素x</td></tr><tr><td>lst.remove(x)</td><td>删除列表lst中元素x</td></tr><tr><td>lst.pop([index])</td><td>返回并删除列表lst指定index位置的元素,<br>默认为列表尾部元素</td></tr><tr><td>lst.clear()</td><td>删除列表lst中所有元素，但保留列表对象，<br>即返回空列表</td></tr><tr><td>lst.index(X)</td><td>返回列表lst中第一个为X的元素的下标</td></tr><tr><td>lst.count(x)</td><td>返回指定元素X在列表lst中出现的次数</td></tr><tr><td>lst.reverse()</td><td>将列表lst逆序，lst发生变化（原地操作）<br>而内置函数reversed(lst)为非原地操作，原lst不变，返回一个新列表</td></tr><tr><td>lst.sort(key=None,reverse=False)</td><td>将lst排序（原地操作）</td></tr><tr><td>lst.copy()</td><td>返回列表lst的==浅复制==</td></tr></tbody></table><blockquote><p><strong>浅复制&amp;深复制</strong><br><br>我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。<br><br><br>浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。这就和我们寻常意义上的复制有所不同了。  </p><blockquote><p>对于简单的 object，用 shallow copy 和 deep copy 没区别<br><br><br>复杂的 object,如 list 中套着 list 的情况，shallow copy中的子list，并未从原object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。</p></blockquote></blockquote><ul><li><a href="http://python.jobbole.com/82294/" target="_blank" rel="noopener">++对象赋值&amp;shallow copy &amp; deep copy++ 博客链接</a></li><li><p>理解<strong>原子对象</strong>和<strong>容器对象</strong></p><ol start="2"><li><p>非原地操作（Python内置函数，运算符+、*等）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=list(range(10))</span><br><span class="line">&gt;&gt;&gt; y=x                             #x,y指向同一个对象，由id(x),id(y)可以看出</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; import random</span><br><span class="line">&gt;&gt;&gt; random.shuffle(x)               #随即打乱</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[3, 7, 1, 6, 8, 2, 0, 9, 4, 5]</span><br><span class="line">&gt;&gt;&gt; x is y</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[3, 7, 1, 6, 8, 2, 0, 9, 4, 5]</span><br><span class="line">&gt;&gt;&gt; x.pop()                         #原地操作</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; x.append(258)                   #原地操作</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[3, 7, 1, 6, 8, 2, 0, 9, 4, 258]</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[3, 7, 1, 6, 8, 2, 0, 9, 4, 258]</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; x.extend([15,51])               #原地操作</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[3, 7, 1, 6, 8, 2, 0, 9, 4, 258, 15, 51]</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; x.insert(0,&apos;insert&apos;)            #原地操作</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[&apos;insert&apos;, 3, 7, 1, 6, 8, 2, 0, 9, 4, 258, 15, 51]</span><br><span class="line">&gt;&gt;&gt; x.remove(7)                     #原地操作</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[&apos;insert&apos;, 3, 1, 6, 8, 2, 0, 9, 4, 258, 15, 51]</span><br><span class="line">&gt;&gt;&gt; x.reverse()                     #list对象本身自带逆序函数，原地操作</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[51, 15, 258, 4, 9, 0, 2, 8, 6, 1, 3, &apos;insert&apos;]</span><br><span class="line">&gt;&gt;&gt; x.pop()</span><br><span class="line">&apos;insert&apos;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[51, 15, 258, 4, 9, 0, 2, 8, 6, 1, 3]</span><br><span class="line">&gt;&gt;&gt; x.sort()                        #原地操作</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[0, 1, 2, 3, 4, 6, 8, 9, 15, 51, 258]</span><br><span class="line">&gt;&gt;&gt; reversed(x)                     #内置函数进行逆序，非原地操作，返回新的对象。x不变</span><br><span class="line">&lt;list_reverseiterator object at 0x0000025635387828&gt;</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[0, 1, 2, 3, 4, 6, 8, 9, 15, 51, 258]</span><br><span class="line">&gt;&gt;&gt; sorted(x,reverse=True)          #非原地操作，产生新的列表</span><br><span class="line">[258, 51, 15, 9, 8, 6, 4, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[0, 1, 2, 3, 4, 6, 8, 9, 15, 51, 258]</span><br><span class="line">&gt;&gt;&gt; x=x+[1,2]                       #非原地操作（*）</span><br><span class="line">&gt;&gt;&gt; id(x)</span><br><span class="line">2569288051976</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2568897570056</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[0, 1, 2, 3, 4, 6, 8, 9, 15, 51, 258]</span><br><span class="line">&gt;&gt;&gt; y+=[1,2]                        #原地操作（与上一语句（*）对比）</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[0, 1, 2, 3, 4, 6, 8, 9, 15, 51, 258, 1, 2]</span><br><span class="line">&gt;&gt;&gt; id(y)</span><br><span class="line">2568897570056</span><br></pre></td></tr></table></figure><blockquote><p>python中内置函数map(),filter(),reduce()等函数是==python函数式编程==的重要体现<br>(reduce()函数在python3中不是内置函数，而是在functools库中)<br></p></blockquote><p>注：下表中的lst不一定是列表，其他可迭代对象均可</p><p>函数 | 功能<br>— | —<br>map.(func,lst) | 返回列表lst中每个元素经过函数func映射后的结果列表，<br>这里的func也可以是lambda函数<br>filter(func,lst) | 将一个单参数函数作用到序列lst上，并返回该序列中使得该函数<br>返回值为True的那些元素组成的filter对象，如果指定函数为None，<br>则返回序列中等价于True的元素所组成的filter对象<br>reduce(func,lst) | 将一个两参数函数以累积方式从左到右依次作用到序列lst上<br>zip(seq1[,sep2[,sep3…]]) | 返回元素为元组的新列表<br>enumerate(seq) | 枚举列表元素，返回enumerate对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=list(range(10))</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; b=list(map(lambda x :chr(x+ord(&apos;A&apos;)),a))</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(b))</span><br><span class="line">[(0, &apos;A&apos;), (1, &apos;B&apos;), (2, &apos;C&apos;), (3, &apos;D&apos;), (4, &apos;E&apos;), (5, &apos;F&apos;), (6, &apos;G&apos;), (7, &apos;H&apos;), (8, &apos;I&apos;), (9, &apos;J&apos;)]</span><br><span class="line">&gt;&gt;&gt; list(filter(lambda x:x&gt;6,a))</span><br><span class="line">[7, 8, 9]</span><br><span class="line">[x&gt;6 for x in a ]</span><br><span class="line">[False, False, False, False, False, False, False, True, True, True]</span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; reduce(lambda i,j:i+j ,a)</span><br><span class="line">45</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><ul><li>通过切片获取列表部分元素</li><li>可以通过切片实现删除、更改、增加元素</li><li>通过切片进行浅复制</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><ul><li><p>[表达式或函数式 for 变量 in 可迭代对象]</p><ol><li>列表推导式结合if语句过滤元素</li><li>列表推导式实现多重循环</li><li>列表推导式实现矩阵转置</li><li>列表推导式内使用函数或复杂表达式</li></ol></li></ul><h2 id="array-array"><a href="#array-array" class="headerlink" title="array.array"></a>array.array</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>array数组类型和C语言中的数组很类似，可以指定数组中存储元素的类型。特点是速度快，可以通过实例方法存储和读取二进制文件。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><hr><h2 id="collection-deque"><a href="#collection-deque" class="headerlink" title="collection.deque"></a>collection.deque</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>列表可以通过pop()方法和append()方法来实现“先进先出”的队列属性，但由于频繁移动元素导致效率不高。deque类型专门对入队出队进行了优化。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><hr><h2 id="元组及具名元组"><a href="#元组及具名元组" class="headerlink" title="元组及具名元组"></a>元组及具名元组</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><h4 id="元组基本知识"><a href="#元组基本知识" class="headerlink" title="元组基本知识"></a>元组基本知识</h4><blockquote><p>元组为不可变序列，支持切片操作，但只能通过切片来访问元组中的元素。可以将元组看成‘常量列表’。<br>当元组中的元素包含可变序列（如列表）时，情况变得不一样。</p></blockquote><blockquote><p>python对元组内部做了优化，其访问和处理速度比列表更快。而且由于其不可改变的特点通常用来==函数调用时进行参数传递==</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a= (1,2,3)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">(1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; b=a[:]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">(1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; c=(3)           #c=3等价，创建含一个元素的元组如d</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; type(c)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; d=(3,)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">(3,)</span><br><span class="line">&gt;&gt;&gt; type(d)</span><br><span class="line">&lt;class &apos;tuple&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; e=()</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; f=tuple()</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; g=tuple([1,2,34,5])</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">(1, 2, 34, 5)</span><br></pre></td></tr></table></figure><h4 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h4><ul><li>格式：（表达式 for 变量 in 序列或迭代对象）</li><li>生成器推导式的结果为一个生成器对象</li></ul><blockquote><p>==生成器对象==：<br>可以使用工厂函数list(),tuple()将其转化为列表或元组，也可以通过生成器对象本身的<strong>next</strong>方法或内置函数next()进行遍历，也可将其直接当做迭代器对象使用。但无论如何遍历或使用，<strong>当所有元素遍历完后，需要重新创建生成器对象才能重新访问其中的元素</strong>。<em>生成器对象的优点是节省内存空间</em></p></blockquote><ul><li>包含yield关键字的函数可以用来创建可迭代的生成器对象</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>尽量不要把可变序列作为元组的元素</li><li>增量赋值不是 <strong>原子操作</strong>，对于可变序列，+=运算符调用–iadd–() 特殊方法，就地操作。而不可变序列则没有–add–()，是通过–add–()方法实现的，此时会创建一个新的对象，完成操作后与原变量关联。</li></ul><hr><h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>collection.namedtuple()是一个工厂函数，用来构建带字段名的元组和带名字的类。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><hr><h2 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h2><ul><li>对多个变量<strong>同时赋值</strong></li><li>同时遍历多个序列</li><li>在实参前加*号可以实现序列解包并在函数调用时进行参数传递</li><li>元组拆包常常用来传递函数参数。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解python</title>
      <link href="/2019/01/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python/"/>
      <url>/2019/01/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解python"><a href="#深入理解python" class="headerlink" title="深入理解python"></a>深入理解python</h1><p>主要深究一下Python语言编程的内部机理</p><h2 id="变量和对象"><a href="#变量和对象" class="headerlink" title="变量和对象"></a>变量和对象</h2><p>python是完全面向对象的高级编程语言，Python中一切皆为对象：像普通的Python内置数据结构int、list等以及函数都是对象。</p><p>​    变量用于在程序运行中记录信息。既然是记录信息，那么变量势必会占据一定内存大小来存储数据。但是对于python语言而言，变量并不占据存储数据的内存空间。这里牵扯到变量的行为或者称为 <strong>变量语义</strong>。</p><p>​    实际上，存在两种截然不同的变量语义：</p><ul><li><p><strong>值语义和引用语义</strong></p><blockquote><p>在<strong>C语言</strong>中，C变量是值的容器，用于保存相应的数据。变量一经定义就将被分配一定的内存空间，被保存的值不是独立的实体，可以经过赋值进行更改。变量的这种行为就称为 <strong><em>值语义</em></strong>。</p><p>变量采用值语义的这种行为,显然 <strong>变量需要指定类型进行定义</strong>。基于这种语义，变量赋值就是把变量内存储的值进行拷贝。对于结构较大的结构变量（结构体，数组等），如果不希望完全拷贝所有值，C语言提供指针来解决。</p></blockquote><blockquote><p>对于<strong>python</strong>而言，变量并不是值的容器，也就是说变量并不存储值，而是存储着“值”对象的唯一标识。在python中，一切都是对象，所以“值”是各种数据类型的对象实例，是一个独立的实体。把“值”赋值给变量，其实是将变量名关联这个“值”（或者说引用）。这种方式称为 <strong><em>引用语义</em></strong>。</p><p>基于这种方式，Python变量是 <strong>赋值即定义</strong>，使用变量，其实是通过变量来使用与之关联的对象。变量没有类型，但是与变量相关联的对象的类型是确定且必须明确的。<strong>所以Python仍然是强类型语言</strong>。因为Python中各种数据类型都是由类定义的，在类中定义了数据的规范。创建类的对象来存储数据，然后通过变量关联来实现对数据的使用。</p></blockquote></li></ul><p>由于Python变量的这种引用语义，有必要深入了解其 <strong>值共享机制</strong>。</p><h3 id="共享机制"><a href="#共享机制" class="headerlink" title="共享机制"></a>共享机制</h3><ol><li><strong>赋值与共享</strong></li></ol><p><strong>当一个变量给另一个变量赋值时，两个变量关联同一个对象。</strong> 如果这个对象是可变的组合对象（如列表、字典集合等），那么无论通过那个变量对该组合对象进行更改，那么通过另一个变量引用的取值也将随之改变。因为这两个变量关联的是同一个对象。即这两个变量共享这个对象，除非将变量关联到别的对象上，否则两个变量所引用的值永远保持一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"adfag"</span></span><br><span class="line">b = a</span><br><span class="line">c = [<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">d = c</span><br><span class="line">print(<span class="string">"variableName-type-id:"</span>)</span><br><span class="line">print(<span class="string">"a-"</span>, type(a),<span class="string">"-"</span>, id(a))</span><br><span class="line">print(<span class="string">"b-"</span>, type(b),<span class="string">"-"</span>, id(b))</span><br><span class="line">print(<span class="string">"c-"</span>, type(c),<span class="string">"-"</span>, id(c))</span><br><span class="line">print(<span class="string">"d-"</span>, type(d),<span class="string">"-"</span>, id(d))</span><br><span class="line"></span><br><span class="line">a1 = <span class="string">'sdfn'</span></span><br><span class="line">a2 = <span class="string">'sdfn'</span></span><br><span class="line">print(a1 <span class="keyword">is</span> a2)</span><br><span class="line">print(id(a1), id(a2))</span><br><span class="line">b1 = [<span class="number">23</span>,[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">b2 = [<span class="number">23</span>,[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">print(id(b1), id(b2))</span><br><span class="line">print(<span class="string">"element_id"</span>)</span><br><span class="line">print(<span class="string">'['</span>,id(b1[<span class="number">0</span>]), id(b1[<span class="number">1</span>]),<span class="string">'['</span>,id(b1[<span class="number">1</span>][<span class="number">0</span>]),id(b1[<span class="number">1</span>][<span class="number">1</span>]),<span class="string">"]]"</span>)</span><br><span class="line">print(<span class="string">'['</span>,id(b2[<span class="number">0</span>]), id(b2[<span class="number">1</span>]),<span class="string">'['</span>,id(b2[<span class="number">1</span>][<span class="number">0</span>]),id(b2[<span class="number">1</span>][<span class="number">1</span>]),<span class="string">"]]"</span>)</span><br></pre></td></tr></table></figure><pre><code>variableName-type-id:a- &lt;class &apos;str&apos;&gt; - 140256053261120b- &lt;class &apos;str&apos;&gt; - 140256053261120c- &lt;class &apos;list&apos;&gt; - 140256052910600d- &lt;class &apos;list&apos;&gt; - 140256052910600True140256053263696 140256053263696140256052910856 140256052911112element_id[ 93854117399776 140256052910536 [ 93854117399104 93854117399200 ]][ 93854117399776 140256052910920 [ 93854117399104 93854117399200 ]]</code></pre><p>从上面运行结果来看，<strong>对于组合对象（对象内元素由多个相同或不同类型的对象组成，这种组合对象相当于一个容器，其存储的是各个元素的引用），即使组合对象元素完全一样，但仍创建了不同的组合对象，而并非两个变量关联同一个组合对象。</strong></p><p>其实要弄懂python的默认共享机制，只需明白一个原则：<strong>python内部机制会尽可能的减少内存开支</strong>。对于嵌套的多层组合对象，python默认操作共享的都是底层独立的对象实体。这种默认的共享机制针对于不可变的非组合对象实例，因此并不会对程序产生不必要的副作用。</p><blockquote><p>上述程序，a1 = ‘sdfn’语句先在内存中创建了一个字符串str类型的对象，按照Python赋值即定义的机制，也定义了变量a1；接着 a2 = ‘sdfn’语句,本来应该在创建一个str类的实例，但Python内部机制会自动共享底层相同的非组合对象实体，所以a1、a2关联同一个str对象实例。但这并不会对程序产生不可预见的错误。</p></blockquote><ol start="2"><li><strong>拷贝与共享</strong></li></ol><p>python 中默认的拷贝都为浅拷贝（即只对最上面一层进行拷贝）。比如一个列表，列表中的元素仍是复合数据类型。</p><p>为了便于理解组合类型的共享机制，首先来介绍一下Python内置序列的分类：</p><ul><li><p><strong>按类型分</strong></p><ol><li>容器序列</li></ol><p>像list、tuple和collections.deque等，容器序列的特点是其能存放不同类型的数据。</p><ol start="2"><li>扁平序列</li></ol><p>像str、bytes、bytearray、memoryview、array.array、numpy.ndarray等，这类序列只能存放指定的相同类型的数据。</p><p><strong>容器序列由于可以存放不同类型的数据，其实现机制是存放各个数据元素的引用。所以Python默认复制操作只复制最上层的引用。而扁平序列可以看做是一串连续的内存空间。</strong> <em>从宏观角度看，容器序列是由各个相同或不同类型对象组成的组合对象，其元素都是独立的对象实例的引用；扁平序列的元素并不是独立的对象实例。</em></p></li></ul><ul><li><p><strong>按能否修改元素来分</strong></p><ol><li>可变序列</li></ol><p>list、byteattay、collections.deque、memoryview、array.array</p><ol start="2"><li>不可变序列</li></ol><p>tuple、str、bytes</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lst_init = [<span class="string">"af"</span>, (<span class="number">1</span>,<span class="number">2</span>), [<span class="number">2</span>,<span class="number">4</span>,[<span class="number">6</span>,<span class="number">7</span>]], <span class="number">50</span>]</span><br><span class="line">lst_copy = lst_init.copy()   <span class="comment"># 等价于 lst_copy = lst[:]</span></span><br><span class="line">lst_qiep = lst_init[<span class="number">1</span>:]</span><br><span class="line">lst_init_elementId = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_init]</span><br><span class="line">lst_copy_elementId = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_copy]</span><br><span class="line">lst_qiep_elementId = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_qiep]</span><br><span class="line">print(<span class="string">"variableName-value-[id]"</span>)</span><br><span class="line">print(<span class="string">"lst_init-"</span>,lst_init, lst_init_elementId)</span><br><span class="line">print(<span class="string">"lst_copy-"</span>,lst_copy, lst_copy_elementId)</span><br><span class="line">print(<span class="string">"lst_qiep-"</span>,lst_qiep, lst_qiep_elementId)</span><br><span class="line">lst_qiep.append(<span class="string">'af'</span>)</span><br><span class="line">lst_qiep[<span class="number">1</span>][<span class="number">2</span>]=<span class="string">'af'</span></span><br><span class="line">lst_init_elementId_ = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_init]</span><br><span class="line">lst_copy_elementId_ = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_copy]</span><br><span class="line">lst_qiep_elementId_ = [id(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst_qiep]</span><br><span class="line">print(<span class="string">"after modify:  variableName-value-[id]"</span>)</span><br><span class="line">print(<span class="string">"lst_init-"</span>,lst_init, lst_init_elementId_)</span><br><span class="line">print(<span class="string">"lst_copy-"</span>,lst_copy, lst_copy_elementId_)</span><br><span class="line">print(<span class="string">"lst_qiep-"</span>,lst_qiep, lst_qiep_elementId_)</span><br><span class="line"></span><br><span class="line">print(id(lst_init[<span class="number">2</span>][<span class="number">2</span>]),id(lst_copy[<span class="number">2</span>][<span class="number">2</span>]), id(lst_qiep[<span class="number">1</span>][<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><pre><code>variableName-value-[id]lst_init- [&apos;af&apos;, (1, 2), [2, 4, [6, 7]], 50] [140256169915872, 140256104558664, 140256054097608, 93854117400640]lst_copy- [&apos;af&apos;, (1, 2), [2, 4, [6, 7]], 50] [140256169915872, 140256104558664, 140256054097608, 93854117400640]lst_qiep- [(1, 2), [2, 4, [6, 7]], 50] [140256104558664, 140256054097608, 93854117400640]after modify:  variableName-value-[id]lst_init- [&apos;af&apos;, (1, 2), [2, 4, &apos;af&apos;], 50] [140256169915872, 140256104558664, 140256054097608, 93854117400640]lst_copy- [&apos;af&apos;, (1, 2), [2, 4, &apos;af&apos;], 50] [140256169915872, 140256104558664, 140256054097608, 93854117400640]lst_qiep- [(1, 2), [2, 4, &apos;af&apos;], 50, &apos;af&apos;] [140256104558664, 140256054097608, 93854117400640, 140256169915872]140256169915872 140256169915872 140256169915872</code></pre><p>首先，列表lst中存储的都是各个元素数据对象的引用；浅拷贝之后，lst_copy中只是把各个对象的引用拷贝过来，其中所有的元素对象都是共享的。</p><p>从上面运行的结果还发现，python在创建一个对象实例时，会采用尽量减少内存的原则，即最大化的利用共享机制：先检测是否存在一样的对象，如果存在则直接引用，而不会另外创建。上例中的字符串“af”只存在一个对象实体，但却被多次引用，或者说被关联了多个变量。</p><ol start="3"><li><strong>函数实参与共享</strong></li></ol><p>在C或C++语言中，如果仅仅采用<strong>值传递</strong>方式进行函数参数传递的话，在函数内部无法改变外部的实参变量的值。除非通过传递指针或者采用C++中的 <strong>引用传递</strong>。而在python中，<strong>函数参数传递时，外部实参和内部形参完全是采用共享机制</strong>。但这需要特别注意：如果实参是可变的组合类型，需要留意函数内部通过形参对可变组合对象的更改。</p><p>还有当函数形参具有默认值，且默认值是可变类型时。要特别注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">x = test.pop() * <span class="number">2</span> + test.pop()</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><pre><code>11</code></pre><h4 id="参数和运算对象的求值顺序"><a href="#参数和运算对象的求值顺序" class="headerlink" title="参数和运算对象的求值顺序"></a>参数和运算对象的求值顺序</h4><p>对于一个表达式而言，有时表达式的求值顺序会对结果产生影响。如上例，表达式从左到右求值，结果为4*2+3；若从右到左求值，结果为3*2+4。这称为<strong>表达式的副作用</strong>。但在Python中明确规定求值顺序为从左到右。对于函数传递参数时，实参列表也是从左到右求值，所以要注意前面的实参求解过程中是否会对后面的实参表达式的值产生影响。</p><h3 id="逻辑判断和是否同一对象"><a href="#逻辑判断和是否同一对象" class="headerlink" title="逻辑判断和是否同一对象"></a>逻辑判断和是否同一对象</h3><p>在python中，空的组合类型（空列表，空集合，空元组，空字符串等）都为假；且对于<strong>空的不可变组合对象</strong>，Python中具有唯一性（即只存在一个None对象，一个空元组对象，一个空冻结集合对象，一个空字符串对象）。所以要注意“==”和“is”之间的区别，前者是比较值，后者判断是否为同一对象。</p><h3 id="变量、函数名、类型——一切皆对象"><a href="#变量、函数名、类型——一切皆对象" class="headerlink" title="变量、函数名、类型——一切皆对象"></a>变量、函数名、类型——一切皆对象</h3><p>在python中，变量、函数名、类型名等完全一样，它们都能记录信息（关联对象），能够通过赋值修改，其实可以将它们统称为变量。赋值语句是给变量关联值的一种机制，被关联的值用表达式描述；def关键字专门用于给变量关联函数对象，此时更愿意称为函数名，但其和变量毫无差别，甚至可以通过赋值将函数名（变量）关联一个表达式的值；class关键字专门用于给变量关联新的类型（定义新类型）。</p><p>但需要说明一下，这里说的完全一样只是在宏观上的表象，因为变量、函数名、类型名（或者统称为变量）只是一个名字或者说标识（理解成C++里的引用），只是为了方便使用与其关联的对象。但是对于不用对象的操作肯定不同，比如：global、nonlocal关键字能将变量声明为全局变量和非局部变量，但却不能声明函数或类型为全局或非局部。根本原因是<strong>操作都是针对于变量所关联的对象</strong>。</p><h2 id="程序语义实现"><a href="#程序语义实现" class="headerlink" title="程序语义实现"></a>程序语义实现</h2><p>程序运行主要靠<strong><em>环境</em></strong>和<strong><em>状态</em></strong>的变化实现。</p><ul><li>环境可以理解为程序运时某一阶段的所有变量（包括函数和类型）</li><li>状态则是某一阶段所有变量所关联的对象的值的情况</li></ul><h3 id="程序执行中环境和状态的变化"><a href="#程序执行中环境和状态的变化" class="headerlink" title="程序执行中环境和状态的变化"></a>程序执行中环境和状态的变化</h3><ul><li><strong>名字空间</strong></li></ul><p>Python解释器启动时，其自动创建的内置初始环境中含有一个<strong>内置名字空间</strong>。里面记录着Python内置的标准类型，标准函数，标准常量，各种异常名。之后会再建立一个<strong>全局名字空间</strong>作为当前的名字空间。内置名字空间是全局名字空间的<strong>外围名字空间</strong>。</p><p>在程序中定义函数或声明变量等其他能改变环境的操作默认只对当前名字空间产生作用。除非有global、nonlocal关键字声明。<strong><em>程序执行到调用函数语句时，会为函数创建一个局部名字空间，函数定义所在的名字空间为该名字空间的外围名字空间。（名字空间逐层嵌套）。若调用递归函数，则会创建多个局部名字空间，这些局部名字空间都以递归函数定义所在名字空间为外围名字空间。</em></strong></p><p>当函数调用执行完成后，创建的函数局部名字空间将被删除。（<strong>对于生成器函数和工厂函数（函数闭包）而言，由于其特殊的工作原理，其局部名字空间在函数调用结束后并不会立即删除。具体原理见后续</strong>）程序运行时，默认情况下（无global、nonlocal关键字声明）总是先在当前名字空间里查找变量名，在当前名字空间里查找不到时逐层往外查找。</p><blockquote><p><strong>对于global声明，程序运行到函数体内，以为函数创建的局部名字空间为当前名字空间，被global声明的变量直接被加到全局名字空间内，使用该变量时直接在全局名字空间里查找。当global声明的变量在函数外没有定义，global语句默认会自动将其加到全局名字空间</strong></p><p><strong>对于nonlocal声明（非局部变量声明），使用非局部变量时，解释器直接从当前名字空间的直接外围名字空间（非全局名字空间）查找，若查找不到，再逐层往外围的非全局名字空间进行查找。外围非全局名字空间逐层都未找到就会报错，报错只发生在该变量没有定义或只在全局名字空间里定义了。</strong></p></blockquote><p>由于python赋值即定义的特性，在局部函数内，若不通过global或nonlocal声明，在函数内部无法改变其外围名字空间里的变量值。但是可以使用外围名字空间里的变量，因为变量作用域一般都是像内层嵌套的作用域进行延伸的。</p><p>在者需要注意的是，在执行函数调用时，python解释器首先会根据函数体（赋值语句）为该函数创建局部名字空间。然后再一条一条的执行函数体内的语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g1 = <span class="number">3</span></span><br><span class="line">g2 = [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    localV = a + <span class="number">10</span></span><br><span class="line">    g2.append(a)</span><br><span class="line">    <span class="keyword">return</span> localV</span><br><span class="line">g1 = func(g1)</span><br><span class="line">print(g1,g2)</span><br><span class="line">print(dir())</span><br></pre></td></tr></table></figure><pre><code>13 [2, 4, 3][&apos;In&apos;, &apos;Out&apos;, &apos;_&apos;, &apos;__&apos;, &apos;___&apos;, &apos;__builtin__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_dh&apos;, &apos;_i&apos;, &apos;_i1&apos;, &apos;_i10&apos;, &apos;_i11&apos;, &apos;_i12&apos;, &apos;_i13&apos;, &apos;_i14&apos;, &apos;_i15&apos;, &apos;_i16&apos;, &apos;_i17&apos;, &apos;_i18&apos;, &apos;_i19&apos;, &apos;_i2&apos;, &apos;_i20&apos;, &apos;_i21&apos;, &apos;_i3&apos;, &apos;_i4&apos;, &apos;_i5&apos;, &apos;_i6&apos;, &apos;_i7&apos;, &apos;_i8&apos;, &apos;_i9&apos;, &apos;_ih&apos;, &apos;_ii&apos;, &apos;_iii&apos;, &apos;_oh&apos;, &apos;bibao_fibonaqi&apos;, &apos;count&apos;, &apos;exit&apos;, &apos;fibonaqi&apos;, &apos;fibonaqi_&apos;, &apos;func&apos;, &apos;g&apos;, &apos;g1&apos;, &apos;g2&apos;, &apos;gen_fibonaqi&apos;, &apos;get_ipython&apos;, &apos;i&apos;, &apos;quit&apos;, &apos;result&apos;, &apos;x&apos;]</code></pre><h3 id="生成器和函数闭包"><a href="#生成器和函数闭包" class="headerlink" title="生成器和函数闭包"></a>生成器和函数闭包</h3><p>生成器函数和闭包函数（工厂函数）都是特殊的函数。特殊就特殊在其工作机制上，普通函数调用时，解释器会创建一个局部名字空间，函数调用结束，该局部名字空间便会自动回收；但生成器函数和闭包函数则不然：</p><h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><p>函数体里包含yield语句。yield语句有两种形式：</p><ul><li><strong>yield 表达式</strong>    <em>#直接返回表达式的值</em></li><li><strong>yield from <em>subiterator</em></strong>     <em>#从子迭代器subiterator逐个返回值</em></li></ul><p><strong>调用生成器函数，返回的是一个生成器对象。生成器对象属于迭代器。</strong></p><ul><li><strong>迭代器对象</strong>：能执行next()操作的对象都称为迭代器对象。像range、map、filter等内置函数的返回值</li><li><strong>可迭代对象</strong>：能在for语句中逐个迭代的对象。像列表、元组等</li></ul><h5 id="生成器运行原理"><a href="#生成器运行原理" class="headerlink" title="生成器运行原理"></a>生成器运行原理</h5><p>生成器对象可以理解成一种数据抽象（具有内部状态，内部实现方式屏蔽，具有抽象行为），生成器对象存储的是生成数据的规则，并不存储具体数据。利用生成器函数产生的生成器对象在使用时（生成器对象的使用归根结底就是向其索要下一个值，例如用于for语句或next()函数），当向生成器对象索要下一个值时，该对象就会执行生成器函数体代码，直到yield语句返回下一个值，函数体在下一次求值是从上一次yield返回值处继续执行。在该生成器对象没有被释放之前，保存其内部状态（执行到何处等）的名字空间并不会被解释器回收。<strong>当生成器对象在执行函数体时遇到return语句或执行完所有函数体（即生成器对象的所有值都被求出）时，会引发stopIteration异常，该异常会使得for循环结束。</strong></p><p>生成器对象归根结底是生成器类型的实例，可以调用类的实例方法gen.send()、gen.throw()、gen.close()。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是一种编程技术。因为其返回值是一个函数，又称为工厂函数。</p><p>基本结构：定义一个闭包函数f，其中定义若干局部变量构成f的局部状态，在f里定义一个使用<strong>非局部状态</strong>的局部函数（<strong>该函数依赖于调用f时创建的名字空间</strong>），调用f，建立f的局部作用域后返回局部函数，实际返回的是一个闭包。函数f被称为工厂函数，每次调用f都会返回一个新闭包。</p><p>返回闭包是通过返回<strong>闭包二元组</strong>来实现的，闭包二元组逻辑上表现为(闭包函数内部定义生成的函数对象，本次调用闭包函数所创建的名字空间)。即调用闭包函数返回值不仅包括生成的函数对象，还包含生成此函数对象时的内部状态。虽然在闭包函数里的函数定义代码是固定不变的，但由于每次调用闭包函数都会创建新的名字空间，因此返回的闭包二元组不同，从而使得每次调用闭包函数返回的函数闭包都不同。</p><p>下面分别用生成器和闭包实现斐波那契数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonaqi</span><span class="params">(limit)</span>:</span></span><br><span class="line">    f0, f1 = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(limit):</span><br><span class="line">        <span class="keyword">yield</span> f1</span><br><span class="line">        f0, f1 = f1, f0 + f1</span><br><span class="line">        </span><br><span class="line">gen_fibonaqi = fibonaqi(<span class="number">10</span>)</span><br><span class="line">print(type(gen_fibonaqi))</span><br><span class="line">print(list(gen_fibonaqi))</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;generator&apos;&gt;[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonaqi_</span><span class="params">(limit)</span>:</span></span><br><span class="line">    f0, f1 = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, f0, f1</span><br><span class="line">        <span class="keyword">while</span> count &lt;= limit:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            f0, f1 = f1, f0 + f1</span><br><span class="line">            <span class="keyword">return</span> f0</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gen</span><br><span class="line"></span><br><span class="line">bibao_fibonaqi = fibonaqi_(<span class="number">10</span>)</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x = bibao_fibonaqi()</span><br><span class="line">    <span class="keyword">if</span> x:</span><br><span class="line">        result.append(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(type(bibao_fibonaqi))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;function&apos;&gt;[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv基本IO操作</title>
      <link href="/2019/01/21/opencv%E5%9F%BA%E6%9C%ACIO%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/21/opencv%E5%9F%BA%E6%9C%ACIO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="图像读写及窗口显示"><a href="#图像读写及窗口显示" class="headerlink" title="图像读写及窗口显示"></a>图像读写及窗口显示</h2><ul><li>opencv的 imread() 和 imwrite() 函数支持各种静态图像文件格式。</li></ul><p><a href="https://docs.opencv.org/3.4.3/dc/d2e/tutorial_py_image_display.html" target="_blank" rel="noopener">官方文档参考</a></p><p><strong><em>注：opencv的大部分常用函数都包含在cv2模块中，cv2模块并不意味这是opencv 2.x.x版本。截止到2018年opencv版本已经发布到4.x.x版本了。本笔记所使用的是opencv3.x.x版本。</em></strong></p><h4 id="cv2-imread"><a href="#cv2-imread" class="headerlink" title="cv2.imread()"></a>cv2.imread()</h4><ul><li><p><em>args</em>:</p><ul><li><strong>file_path:</strong> 文件路径（相对路径或绝对路径）</li><li><strong>int flag:</strong> 指定图像的读取方式，cv2模块提供了各种图像读取方式的常量：</li></ul><blockquote><p>cv2.IMREAD_COLOR = 1 : 加载彩色图像。图像的任何透明度都会被忽略。它是默认值。<br><br>cv2.IMREAD_GRAYSCALE = 0 : 加载灰度图像<br><br>cv2.IMREAD_UNCHANGED = -1 : 按原样加载图像，包括alpha通道(透明度信息)</p></blockquote></li><li><p><em>return</em>:<br>返回一份ndarray数组（默认返回的是三通道的三维数组，因为默认图像读取方式为彩色rgb图像）</p></li></ul><p><strong>note</strong>:<br>​      - 在彩色图像的情况下，解码后的图像将以bgr顺序存储通道。<br>​      - 该函数根据内容而不是文件扩展名确定图像的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">rgbimg = cv2.imread(<span class="string">"img_example/image0.jpg"</span>)</span><br><span class="line">grayimg = cv2.imread(<span class="string">"img_example/image0.jpg"</span>, cv2.IMREAD_GRAYSCALE) <span class="comment">#或者直接传递参数0</span></span><br><span class="line">grayimg_ = cv2.imread(<span class="string">"img_example/image0.jpg"</span>, <span class="number">0</span>)</span><br><span class="line">print(grayimg.shape)</span><br><span class="line">print(grayimg_.shape)</span><br><span class="line">print(rgbimg.shape)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(28, 28)</span><br><span class="line">(28, 28)</span><br><span class="line">(28, 28, 3)</span><br></pre></td></tr></table></figure><h4 id="cv2-imwrite"><a href="#cv2-imwrite" class="headerlink" title="cv2.imwrite()"></a>cv2.imwrite()</h4><p><a href="https://docs.opencv.org/3.4.3/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">官方文档参考</a></p><ul><li>args:<ul><li>save_path: 保存图像的路径<br></li><li>image: 需要保存为图片的ndarray数组</li></ul></li><li>return:<ul><li>布尔值表示图像存储是否成功</li></ul></li></ul><p>该函数要求图像为RGB或灰度格式（即image为uint8的二维或三维ndarray数组）</p><h4 id="cv2-imshow"><a href="#cv2-imshow" class="headerlink" title="cv2.imshow()"></a>cv2.imshow()</h4><p>生成一个GUI窗口显示图像。</p><ul><li><em>args</em>:<ul><li>window_name: GUI窗口名称<br></li><li>ndarry: 要显示的图片数组</li></ul></li></ul><p>若单纯的只用imshow()来显示图像，那么该显示图像的窗口将会一闪而过。<br>opencv显示图片通常需要和 <strong>cv2.waitKey()</strong> 函数和 <strong>cv2.destroyAllWindows()</strong> 函数配合使用。</p><h4 id="cv2-waitKey"><a href="#cv2-waitKey" class="headerlink" title="cv2.waitKey()"></a>cv2.waitKey()</h4><p>函数参数为等待键盘触发的时间，单位为毫秒，参数为0表示一直等待按键输入；其返回值是-1(表示在等待时间内没有按键触发)。当有按键触发时，返回值为ASCII码。<br>​    </p><blockquote><p><strong><em>opencv的窗口函数和waitKey()函数相互依赖。opencv的窗口只有在调用waitkey()函数时才会更新，waitKey()函数只有在opencv窗口成为活动窗口时，才能捕获输入信息。</em></strong></p></blockquote><h4 id="cv2-destroyAllWindows"><a href="#cv2-destroyAllWindows" class="headerlink" title="cv2.destroyAllWindows()"></a>cv2.destroyAllWindows()</h4><p>该函数将关闭所有打开的GUI窗口。<br>​<br>还能使用Matplotlib绘图库来显示图片。<a href="https://blog.csdn.net/u014630987/article/details/76713814" target="_blank" rel="noopener">详见</a></p><p><a href="https://docs.opencv.org/3.4.3/dc/d2e/tutorial_py_image_display.html" target="_blank" rel="noopener">matplotlib官方文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"img_example/a.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"test"</span>, img)</span><br><span class="line">k = cv2.waitKey(<span class="number">10000</span>) &amp; <span class="number">0xFF</span>   <span class="comment"># 64位机</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>:         <span class="comment"># wait for ESC key to exit</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>): <span class="comment"># wait for 's' key to save and exit</span></span><br><span class="line">    cv2.imwrite(<span class="string">'a.png'</span>,img)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"><span class="keyword">elif</span> k == <span class="number">-1</span> &amp; <span class="number">0xff</span>:  <span class="comment">#在10000毫秒等待时间内无按键触发</span></span><br><span class="line">    print(<span class="string">"no key is pushed"</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no key is pushed</span><br></pre></td></tr></table></figure><p>pillow图像处理库是python最基本的图像库。</p><p><a href="https://blog.csdn.net/u013010889/article/details/54347089" target="_blank" rel="noopener">OpenCV、Skimage、PIL图像处理的细节差异</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">grag_img = Image.open(<span class="string">"img_example/image0.jpg"</span>)</span><br><span class="line">print(type(grag_img))</span><br><span class="line">grag_img.show()</span><br><span class="line">print(grag_img)</span><br><span class="line">print(grag_img.size)</span><br><span class="line">print(grag_img.mode)</span><br><span class="line">a = np.array(grag_img)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(a.dtype)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;PIL.JpegImagePlugin.JpegImageFile&apos;&gt;</span><br><span class="line">&lt;PIL.JpegImagePlugin.JpegImageFile image mode=L size=28x28 at 0x7F25D68931D0&gt;</span><br><span class="line">(28, 28)</span><br><span class="line">L</span><br><span class="line">(28, 28)</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure><h2 id="视频文件读写及帧显示"><a href="#视频文件读写及帧显示" class="headerlink" title="视频文件读写及帧显示"></a>视频文件读写及帧显示</h2><p>opencv读写视频是通过VideoCapture类和VideoWrite类来实现的。</p><h3 id="VideoCapture类"><a href="#VideoCapture类" class="headerlink" title="VideoCapture类"></a>VideoCapture类</h3><p>   <a href="https://docs.opencv.org/3.4.3/d8/dfe/classcv_1_1VideoCapture.html" target="_blank" rel="noopener">参考文档</a></p><h4 id="cv2-VideoCapture-cv2-VideoCapture-filepath-cv2-VideoCapture-filepath-apiPreference-cv2-VideoCapture-index"><a href="#cv2-VideoCapture-cv2-VideoCapture-filepath-cv2-VideoCapture-filepath-apiPreference-cv2-VideoCapture-index" class="headerlink" title="cv2.VideoCapture()  cv2.VideoCapture(filepath) cv2.VideoCapture(filepath, apiPreference) cv2.VideoCapture(index)"></a>cv2.VideoCapture() <br> cv2.VideoCapture(filepath) <br>cv2.VideoCapture(filepath, apiPreference)<br> cv2.VideoCapture(index)</h4><p>重载的videocapture类构造函数。<br>​<br>​    当类构造函数无任何参数时，只声明一个videocapture类的实例。然后可以通过open()类方法来初始化或重新初始化（打开视频文件或摄像头设备）。</p><ul><li><p>args:</p><ul><li>filepath: 视频文件的路径</li><li>apiPreference： 指定后端api库，用于执行特定的阅读器实现。 <a href="https://docs.opencv.org/3.4.3/d4/d15/group__videoio__flags__base.html#ga023786be1ee68a9105bf2e48c700294d" target="_blank" rel="noopener">后端api参考</a><br>opencv提供一下VideoCapture API后端标识符：<ul><li><strong>cv2.CAP_FFMPEG</strong></li><li><strong>cv2.CAP_IMAGES</strong></li><li><strong>cv2.CAP_DSHOW</strong></li></ul></li><li>index: 摄像头的设备索引号。笔记本默认摄像头编号0（或-1）。</li></ul><blockquote><p>有时，VideoCapture可能没有初始化捕获。在这种情况下，代码显示错误。您可以通过方法VideoCapture.isopen()检查它是否初始化。可以使用VideoCapture.open()打开它。</p></blockquote></li></ul><h4 id="cv2-VideoCapture-release"><a href="#cv2-VideoCapture-release" class="headerlink" title="cv2.VideoCapture.release()"></a>cv2.VideoCapture.release()</h4><p>关闭视频文件或捕获设备</p><pre><code>无需参数，返回值为None</code></pre><blockquote><p>当声明videocapture类并打开视频文件或捕获设备，最后都要调用release()方法关闭视频文件或捕获设备。</p></blockquote><h4 id="cv2-VideoCapture-open-filename-cv2-VideoCapture-open-filename-apiPreference-cv2-VideoCapture-open-index"><a href="#cv2-VideoCapture-open-filename-cv2-VideoCapture-open-filename-apiPreference-cv2-VideoCapture-open-index" class="headerlink" title="cv2.VideoCapture.open(filename)  cv2.VideoCapture.open(filename, apiPreference)  cv2.VideoCapture.open(index)"></a>cv2.VideoCapture.open(filename) <br> cv2.VideoCapture.open(filename, apiPreference) <br> cv2.VideoCapture.open(index)</h4><p>函数重载；打开视频文件或捕获设备，用于视频捕获的videocapture类<br>​    </p><ul><li><p>args：参考videocapture类构造函数</p></li><li><p>return：布尔值。如果文件或设备打开正常，则返回true</p><blockquote><p>cv2.VideoCapture.open()方法首先调用VideoCapture.release()关闭已经打开的文件或相机。</p></blockquote></li></ul><h4 id="cv2-VideoCapture-isOpened"><a href="#cv2-VideoCapture-isOpened" class="headerlink" title="cv2.VideoCapture.isOpened()"></a>cv2.VideoCapture.isOpened()</h4><p>用于检测videocapture类实例是否初始化（视频文件或设备正确打开）</p><ul><li>args: 无</li><li>return：布尔值。如果之前对VideoCapture构造函数或VideoCapture.open的调用成功，该方法返回true。</li></ul><h4 id="cv2-VideoCapture-read"><a href="#cv2-VideoCapture-read" class="headerlink" title="cv2.VideoCapture.read()"></a>cv2.VideoCapture.read()</h4><p>抓取、解码并返回下一个视频帧。</p><ul><li><p>args:</p><ul><li>无参数</li></ul></li><li><p>return：</p><ul><li>布尔类型返回值：表示视频帧读取的状态。<br></li><li>image：读取的视频帧。类型为ndarray数组</li></ul><p>如果没有抓取帧(相机已经断开连接，或者视频文件中没有更多的帧)，方法第一个返回值为false，第二个返回值为None。</p></li></ul><h4 id="cv2-VideoCapture-grab-和-cv2-VideoCapture-retrive"><a href="#cv2-VideoCapture-grab-和-cv2-VideoCapture-retrive" class="headerlink" title="cv2.VideoCapture.grab() 和 cv2.VideoCapture.retrive()"></a>cv2.VideoCapture.grab() 和 cv2.VideoCapture.retrive()</h4><p>当需要同步一组摄像头或一个多头摄像头（如立体摄像头）时，read()方法不在适用。</p><pre><code>两个函数都无需参数；grab()返回布尔值表示抓取的状态，retrive()返回值和read()一致</code></pre><blockquote><p>该功能的主要用途是在多摄像机环境中，特别是在摄像机没有硬件同步的情况下。也就是说，对每个相机调用VideoCapture.grab()，然后调用较慢的方法VideoCapture.retrieve()对每个相机进行解码并获取帧。通过这种方法，消除了解码或运动jpeg解压等开销，使从不同相机检索到的帧更接近。</p></blockquote><blockquote><p>另外，当连接的摄像头为多头摄像头(如立体摄像头或Kinect设备)时，从摄像头中获取数据的正确方法是先调用VideoCapture.grab，然后调用VideoCapture.retrieve()，使用不同的通道参数值进行一次或多次调用。</p></blockquote><h4 id="cv2-VideoCapture-get-propId"><a href="#cv2-VideoCapture-get-propId" class="headerlink" title="cv2.VideoCapture.get(propId)"></a>cv2.VideoCapture.get(propId)</h4><p>用于获取指定的VideoCapture属性（property）</p><ul><li>args:<ul><li>propld: 属性标识符。它可以是下列等等: <a href="https://docs.opencv.org/3.4.3/d4/d15/group__videoio__flags__base.html#ggaeb8dd9c89c10a5c63c139bf7c4f5704dab26d2ba37086662261148e9fe93eecad" target="_blank" rel="noopener">参考文档</a><ol><li><strong>CV2.CAP_PROP_FRAME_WIDTH</strong> Width of the frames in the video stream.</li><li><strong>CV2.CAP_PROP_FRAME_HEIGHT</strong> Height of the frames in the video stream.</li><li><strong>CV2.CAP_PROP_FPS</strong> Frame rate.</li><li><strong>CV2.CAP_PROP_FOURCC</strong> 4-character code of codec.</li></ol></li></ul></li></ul><h4 id="cv2-VideoCapture-set-propId-value"><a href="#cv2-VideoCapture-set-propId-value" class="headerlink" title="cv2.VideoCapture.set(propId, value)"></a>cv2.VideoCapture.set(propId, value)</h4><p>设置videocapture实例的属性</p><ul><li>args：<ul><li>propld: 属性标识符。同见<a href="https://docs.opencv.org/3.4.3/d4/d15/group__videoio__flags__base.html#ggaeb8dd9c89c10a5c63c139bf7c4f5704dab26d2ba37086662261148e9fe93eecad" target="_blank" rel="noopener">参考文档</a><br></li><li>value: 属性值</li></ul></li></ul><h3 id="videoWriter类"><a href="#videoWriter类" class="headerlink" title="videoWriter类"></a>videoWriter类</h3><h4 id="cv2-VideoWriter-cv2-VideoWriter-filename-fourcc-fps-frameSize-isColor-cv2-VideoWriter-filename-apiPreference-fourcc-fps-frameSize-isColor"><a href="#cv2-VideoWriter-cv2-VideoWriter-filename-fourcc-fps-frameSize-isColor-cv2-VideoWriter-filename-apiPreference-fourcc-fps-frameSize-isColor" class="headerlink" title="cv2.VideoWriter()   cv2.VideoWriter( filename, fourcc, fps, frameSize [, isColor] )  cv2.VideoWriter( filename, apiPreference, fourcc, fps, frameSize [, isColor] )"></a>cv2.VideoWriter()  <br> cv2.VideoWriter( filename, fourcc, fps, frameSize [, isColor] ) <br> cv2.VideoWriter( filename, apiPreference, fourcc, fps, frameSize [, isColor] )</h4><p>重载的videowrite类构造函数。<br>当函数无任何参数时，只声明一个videoWrite类实例，随后可以通过open()类方法来初始化或重新初始化videoWrite实例。<br>​    </p><ul><li>args：<ul><li>filename: 文件存储路径</li><li>fourcc: 用于压缩帧的编解码器的4个字符代码。</li><li>fps: 创建的视频流的帧速率</li><li>frameSize: 视频帧的大小</li><li>isColor: 可选参数。如果它不是0，编码器将期望并编码颜色帧，否则它将与灰度帧一起工作(该标志目前仅在Windows上受支持)</li></ul></li><li>return：<ul><li>返回videoWrite实例</li></ul></li><li>note：<br>-fourcc编解码器类型应和文件存储路径中的扩展名一致。<a href="# cv2.VideoWriter_fourcc(c1,c2,c3,c4">详见</a>)</li></ul><h4 id="cv2-VideoWriter-write-image"><a href="#cv2-VideoWriter-write-image" class="headerlink" title="cv2.VideoWriter.write( image )"></a>cv2.VideoWriter.write( image )</h4><p>将指定的图像写入视频文件。<strong>image必须与初始化videowrite实例时指定的frame大小相同</strong>。</p><ul><li>arges：<ul><li>image：写入的视频帧。一般来说，彩色图像应该是BGR格式的。</li></ul></li><li>return：None</li></ul><h4 id="cv2-VideoWriter-fourcc-c1-c2-c3-c4"><a href="#cv2-VideoWriter-fourcc-c1-c2-c3-c4" class="headerlink" title="cv2.VideoWriter_fourcc( c1, c2, c3, c4    )"></a>cv2.VideoWriter_fourcc( c1, c2, c3, c4    )</h4><p>将4个字符连接到一个fourcc，用作videoWriter类构造函数或open()的fourcc参数</p><ul><li>return: fourcc code</li></ul><p>常用选项：</p><ul><li>cv2.VideoWrite_fourcc(‘I’,’4’,’2’,’0’): 该选项是一个未压缩的YUV颜色编码，是4:2:0色度子采样。这种编码具有很好的兼容性，但会产生较大文件，文件扩展名为.avi。</li><li>cv2.VideoWrite_fourcc(‘P’,’I’,’M’,’1’): 该选项是MPEG-1编码类型，文件扩展名为.avi。</li><li>cv2.VideoWrite_fourcc(‘X’,’V’,’I’,’D’): 该选项是MPEG-4编码类型，得到的视频文件大小较为平均，文件扩展名为.avi。</li><li>cv2.VideoWrite_fourcc(‘F’,’L’,’V’,’1’): 该选项是一个flash视频，文件扩展名为.flv。</li></ul><h4 id="videoWriter类和videoCapture类一样具有open-、release-、isOpened-、set-、get-方法"><a href="#videoWriter类和videoCapture类一样具有open-、release-、isOpened-、set-、get-方法" class="headerlink" title="videoWriter类和videoCapture类一样具有open()、release()、isOpened()、set()、get()方法"></a>videoWriter类和videoCapture类一样具有open()、release()、isOpened()、set()、get()方法</h4><p><strong><em>以下代码：获取摄像头的帧，并自动保存视频文件</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 构造videocapture类实例（不传递参数，使用open()方法进行初始化）</span></span><br><span class="line">cap = cv2.VideoCapture()</span><br><span class="line"><span class="comment"># 初始化videocapture类实例cap</span></span><br><span class="line">cap.open(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面两句语句与cap = cv2.VideoCapture(0)效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置cap的属性   ????设置无效</span></span><br><span class="line">ret1 = cap.set(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">200</span>)</span><br><span class="line">ret2 = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">300</span>)</span><br><span class="line">print(ret1,ret2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取cap的属性</span></span><br><span class="line">frame_size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)  <span class="comment">#每秒30帧</span></span><br><span class="line">print(<span class="string">"frameSize:"</span>,frame_size,<span class="string">"fps:"</span>,fps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造videowrite类实例，并传递参数进行初始化。</span></span><br><span class="line"><span class="comment"># 经测试，文件写入路径必须事先没有该文件</span></span><br><span class="line">writer = cv2.VideoWriter(<span class="string">"test_videowrite.avi"</span>, cv2.VideoWriter_fourcc(<span class="string">'I'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'0'</span>), fps, frame_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频时长10s</span></span><br><span class="line">videoTime = <span class="number">8</span> * fps - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened() <span class="keyword">and</span> writer.isOpened() <span class="keyword">and</span> videoTime &gt; <span class="number">0</span>):</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 测试属性设置是否有效</span></span><br><span class="line">    <span class="keyword">if</span> videoTime == <span class="number">8</span> * fps - <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"frame.shape"</span>,frame.shape)</span><br><span class="line">        cap_size = (cap.get(cv2.CAP_PROP_FRAME_WIDTH), cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">        print(<span class="string">"cap_size:"</span>,cap_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        <span class="comment"># 将视频帧写入视频文件 </span></span><br><span class="line">        writer.write(frame)</span><br><span class="line">        <span class="comment"># Display the resulting frame</span></span><br><span class="line">        cv2.imshow(<span class="string">'camera'</span>,frame)</span><br><span class="line">        <span class="comment"># 延时1毫秒等待键盘输入，否则返回-1.该函数用于与窗口函数配套使用。</span></span><br><span class="line">        cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        videoTime -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameSize: (640, 480) fps: 30.0</span><br><span class="line">frame.shape (480, 640, 3)</span><br><span class="line">cap_size: (640.0, 480.0)</span><br></pre></td></tr></table></figure><h2 id="GUI窗口及鼠标事件"><a href="#GUI窗口及鼠标事件" class="headerlink" title="GUI窗口及鼠标事件"></a>GUI窗口及鼠标事件</h2><p>openCV的namedWindow()、imshow()和destroyWindow()函数允许指定窗口名来创建、显示和销毁窗口。<strong>任何窗口都可以通过waitKey()函数来获取键盘输入，通过setMouseCallback()函数来获取鼠标输入。</strong>waitKey()函数在介绍opencv显示图片函数imshow()时已经介绍.<br>​    </p><h4 id="cv2-setMouseWindow"><a href="#cv2-setMouseWindow" class="headerlink" title="cv2.setMouseWindow()"></a>cv2.setMouseWindow()</h4><p>setMouseCallback()函数用来创建鼠标回调函数并与指定窗口进行绑定。实现窗口鼠标事件的格式：</p><ul><li>自定义鼠标回调函数有五个参数: <a href="https://docs.opencv.org/3.4.3/d7/dfc/group__highgui.html#gab7aed186e151d5222ef97192912127a4" target="_blank" rel="noopener">参考文档</a><ul><li>event: 鼠标事件参数</li><li>x, y : 鼠标光标所在位置坐标</li><li>flags : 标志参数</li><li>param： 可选参数</li></ul></li></ul><p>当鼠标光标置于指定窗口时，鼠标事件参数、光标位置参数及标志参数就会传递给响应函数，响应函数则会根据传进来参数，按照函数定义完成特定功能。</p><ul><li><strong>openCV不提供任何处理窗口事件的方法</strong>。例如，当单击窗口的关闭按钮时，并不能关闭应用程序。由于openCV有限的事件处理和GUI处理能力，常常将openCV集成到其他应用程序框架中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 定义鼠标事件响应函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onMouseAction</span><span class="params">(event, x, y, flags, param)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#创建GUI窗口</span></span><br><span class="line">cv2.namedWindow(<span class="string">"window_name"</span>)</span><br><span class="line"><span class="comment"># 创建回调函数并和指定窗口绑定</span></span><br><span class="line">cv2.setMouseCallback(<span class="string">"window_name"</span>, onMouseCallback)</span><br><span class="line">cv2.destroyWindow(<span class="string">"window_name"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取鼠标回调事件参数</span></span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> <span class="string">'EVENT'</span> <span class="keyword">in</span> i]</span><br><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">    print( event )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EVENT_FLAG_ALTKEY</span><br><span class="line">EVENT_FLAG_CTRLKEY</span><br><span class="line">EVENT_FLAG_LBUTTON</span><br><span class="line">EVENT_FLAG_MBUTTON</span><br><span class="line">EVENT_FLAG_RBUTTON</span><br><span class="line">EVENT_FLAG_SHIFTKEY</span><br><span class="line">EVENT_LBUTTONDBLCLK</span><br><span class="line">EVENT_LBUTTONDOWN</span><br><span class="line">EVENT_LBUTTONUP</span><br><span class="line">EVENT_MBUTTONDBLCLK</span><br><span class="line">EVENT_MBUTTONDOWN</span><br><span class="line">EVENT_MBUTTONUP</span><br><span class="line">EVENT_MOUSEHWHEEL</span><br><span class="line">EVENT_MOUSEMOVE</span><br><span class="line">EVENT_MOUSEWHEEL</span><br><span class="line">EVENT_RBUTTONDBLCLK</span><br><span class="line">EVENT_RBUTTONDOWN</span><br><span class="line">EVENT_RBUTTONUP</span><br></pre></td></tr></table></figure><h3 id="利用鼠标回调函数和键盘输入函数实现实时拍照"><a href="#利用鼠标回调函数和键盘输入函数实现实时拍照" class="headerlink" title="利用鼠标回调函数和键盘输入函数实现实时拍照"></a>利用鼠标回调函数和键盘输入函数实现实时拍照</h3><p>通过videocapture获取摄像头的视频帧，并利用窗口函数实时显示出来；设置鼠标回调函数；最后实现当按下鼠标左键或键盘任意键时，保存该时刻照片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 定义鼠标回调函数</span></span><br><span class="line">clicked = <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onMouse</span><span class="params">(event, x, y, falgs, param)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> clicked</span><br><span class="line">    <span class="comment">#print(clicked)</span></span><br><span class="line">    clicked = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        clicked = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建GUI窗口</span></span><br><span class="line">cv2.namedWindow(<span class="string">"my camera"</span>)</span><br><span class="line"><span class="comment"># 将鼠标回调函数与窗口绑定</span></span><br><span class="line">cv2.setMouseCallback(<span class="string">"my camera"</span>, onMouse)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"按下鼠标左键或任意键盘按键（除esc键）拍照"</span>)</span><br><span class="line">ret, frame = cap.read()</span><br><span class="line"><span class="keyword">while</span> ret :</span><br><span class="line">    </span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    cv2.imshow(<span class="string">"my camera"</span>, frame)</span><br><span class="line">    k = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果按下esc键则退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">0xff</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k != <span class="number">-1</span> <span class="keyword">or</span> clicked:</span><br><span class="line">        cv2.waitKey(<span class="number">2000</span>)</span><br><span class="line">        photo_filepath = str(datetime.datetime.now()) + <span class="string">".jpg"</span></span><br><span class="line">        flag = cv2.imwrite(photo_filepath, frame)</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">"picture is saved"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 释放videocapture实例和窗口</span></span><br><span class="line">cv2.destroyWindow(<span class="string">"my camera"</span>)</span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按下鼠标左键或任意键盘按键（除esc键）拍照</span><br><span class="line">picture is saved</span><br><span class="line">picture is saved</span><br><span class="line">picture is saved</span><br><span class="line">picture is saved</span><br><span class="line">picture is saved</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow二维卷积</title>
      <link href="/2019/01/20/tf_%E5%8D%B7%E7%A7%AF%E5%87%BD%E6%95%B0/"/>
      <url>/2019/01/20/tf_%E5%8D%B7%E7%A7%AF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="tf-nn-conv2d-二维卷积函数参数说明与实现原理"><a href="#tf-nn-conv2d-二维卷积函数参数说明与实现原理" class="headerlink" title="tf.nn.conv2d() 二维卷积函数参数说明与实现原理"></a>tf.nn.conv2d() 二维卷积函数参数说明与实现原理</h3><p><strong>函数原型</strong></p><blockquote><p>tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, data_format=None, name=None)</p><p>参数说明:</p><p>​    <strong><em>input</em></strong>:  规定为<strong>四维张量</strong>,dtype必须为half \ float32 \ float64.</p><p>​        具有<code>[batch, in_height, in_width, in_channels]</code>这样的shape，具体含义是<code>[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]</code></p><p>​    <strong><em>filter</em></strong>:  和input类型一样的张量</p><p>​        具有<code>[filter_height, filter_width, in_channels, out_channels]</code>这样的shape，具体含义是<code>[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数(输出通道数)</code>]</p><p>​    <strong><em>strides</em></strong>:  长度为4的一维向量, 数据类型为int. 分别表示在四个维度上的卷积的移动步长.</p><p>​    <strong><em>padding</em></strong>: string类型. “SAME” \ “VALID” , 表示填充类型. 在SAME填充方式下卷积返回大小与输入图像大小一致(通过外围填充0实现); VALID填充模式下,卷积返回大小与步长strides有关.</p><p>​    <strong><em>user_cudnn_on_gpu</em></strong>:  bool类型, 默认为True.</p><p>​    <strong><em>data_format</em></strong>: string类型,  指定输入输出数据格式.</p><p>​        默认格式为”NHWC”, 数据按这样的顺序存储：<code>[batch, in_height, in_width, in_channels]</code><br>​        “NCHW”, 数据按这样的顺序存储：<code>[batch, in_channels, in_height, in_width]</code></p><p>​    <strong><em>name</em></strong>: 操作名,可选.</p><p>返回值:</p><p>​     Given an input tensor of shape  <code>[batch, in_height, in_width, in_channels]</code>and a filter / kernel tensor of shape<code>[filter_height, filter_width, in_channels, out_channels]</code>.返回一个四维张量, dtype与input相同.</p><p>​    conv2d实际上执行了以下操作：</p><ol><li>将filter转为二维矩阵，shape为<br><code>[filter_height * filter_width * in_channels, output_channels]</code>.</li><li>从input tensor中提取image patches，每个patch是一个<em>virtual</em> tensor，shape<code>[batch, out_height, out_width, filter_height * filter_width * in_channels]</code>.</li><li>将每个filter矩阵和image patch向量相乘</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">im_mat1 = tf.constant([</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">], dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">im_mat2 = tf.constant([</span><br><span class="line">    [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]],</span><br><span class="line">    </span><br><span class="line">    [[<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]],</span><br><span class="line">    </span><br><span class="line">    [[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]],</span><br><span class="line"></span><br><span class="line">], dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">cons_mat = tf.constant([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]], dtype=tf.float32)</span><br><span class="line">im_input1 = tf.reshape(im_mat1, [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">filter_1 = tf.tile(tf.reshape(cons_mat, shape=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]), [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>])  </span><br><span class="line"><span class="comment">#卷积核维度(2,2,1,3)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tf.tile()只能在原有的维度上进行平铺,无法扩展新维度.</span></span><br><span class="line"><span class="string">filter_1 = tf.tile(tf.expand_dims(tf.expand_dims(cons_mat, 0), 0), [2,2,1,1])</span></span><br><span class="line"><span class="string">filter_1生成单通道的2*2大小卷积核,卷积核数目为3,即输出图像具有3个通道</span></span><br><span class="line"><span class="string">&#123; filter_1[:,:,:,0]:(卷积核1)</span></span><br><span class="line"><span class="string">[[1,1],</span></span><br><span class="line"><span class="string"> [1,1]]</span></span><br><span class="line"><span class="string">  filter_1[:,:,:,1]:(卷积核2)</span></span><br><span class="line"><span class="string">[[2,2],</span></span><br><span class="line"><span class="string"> [2,2]]</span></span><br><span class="line"><span class="string">  filter_1[:,:,:,2]:(卷积核3)</span></span><br><span class="line"><span class="string">[[3,3],</span></span><br><span class="line"><span class="string"> [3,3]] &#125;</span></span><br><span class="line"><span class="string">此卷积核相当于将单通道图像与卷积核1作无填充模式(padding="VALID")二维卷积结果按1:2:3比例扩展成三通道.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">conv_out1 = tf.nn.conv2d(im_input1, filter_1, strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">"VALID"</span>, data_format=<span class="string">"NCHW"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用tf.expand_dims()对cons_mat进行维度扩展与tf.reshape()产生一样效果;</span></span><br><span class="line"><span class="comment">#im_input2 = tf.reshape(im_mat2, [1,3,4,5])</span></span><br><span class="line">im_input2 = tf.expand_dims(im_mat2, <span class="number">0</span>)</span><br><span class="line">filter_2 = tf.tile([[[[<span class="number">0.</span>],[<span class="number">0.</span>],[<span class="number">1.</span>/<span class="number">4</span>]]]], [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>])   <span class="comment">#卷积核维度(2,2,3,1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[[[0.],[0.],[1./4]]]]张量维度为(1,1,3,1)</span></span><br><span class="line"><span class="string">filter_2形成与输入三通道图像对应的三通道卷积核:</span></span><br><span class="line"><span class="string">&#123; filter_2[:,:,0,:]:</span></span><br><span class="line"><span class="string">[[0,0],</span></span><br><span class="line"><span class="string"> [0,0]]</span></span><br><span class="line"><span class="string">  filter_2[:,:,1,:]:</span></span><br><span class="line"><span class="string">[[0,0],</span></span><br><span class="line"><span class="string"> [0,0]]</span></span><br><span class="line"><span class="string">  filter_2[:,:,2,:]:</span></span><br><span class="line"><span class="string">[[1/4,1/4],</span></span><br><span class="line"><span class="string"> [1/4,1/4]] &#125;</span></span><br><span class="line"><span class="string"> 此卷积核相当于提取原三通道图像的第三单通道(无填充模式,图像大小缩小1单位),运行结果见conv_out2.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">conv_out2 = tf.nn.conv2d(im_input2, filter_2, strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">"VALID"</span>, data_format=<span class="string">"NCHW"</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(<span class="string">"image1:\n"</span>, sess.run(im_input1))</span><br><span class="line">    print(<span class="string">"filter1:\n"</span>, sess.run(filter_1))</span><br><span class="line">    print(<span class="string">"conv_out1:\n"</span>, sess.run(conv_out1))</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"image2:\n"</span>, sess.run(im_input2))</span><br><span class="line">    print(<span class="string">"filter2:\n"</span>, sess.run(filter_2))</span><br><span class="line">    print(<span class="string">"conv_out2:\n"</span>, sess.run(conv_out2))</span><br></pre></td></tr></table></figure><pre><code>image1: [[[[5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]]]]filter1: [[[[1. 2. 3.]]   [[1. 2. 3.]]]  [[[1. 2. 3.]]   [[1. 2. 3.]]]]conv_out1: [[[[14. 10.  8.  2.]   [14. 10.  8.  2.]   [14. 10.  8.  2.]]  [[28. 20. 16.  4.]   [28. 20. 16.  4.]   [28. 20. 16.  4.]]  [[42. 30. 24.  6.]   [42. 30. 24.  6.]   [42. 30. 24.  6.]]]]image2: [[[[1. 4. 3. 2. 1.]   [1. 4. 3. 2. 1.]   [1. 4. 3. 2. 1.]   [1. 4. 3. 2. 1.]]  [[5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]   [5. 2. 3. 1. 0.]]  [[2. 2. 2. 2. 2.]   [2. 2. 2. 2. 2.]   [2. 2. 2. 2. 2.]   [2. 2. 2. 2. 2.]]]]filter2: [[[[0.  ]   [0.  ]   [0.25]]  [[0.  ]   [0.  ]   [0.25]]] [[[0.  ]   [0.  ]   [0.25]]  [[0.  ]   [0.  ]   [0.25]]]]conv_out2: [[[[2. 2. 2. 2.]   [2. 2. 2. 2.]   [2. 2. 2. 2.]]]]  </code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>tf.nn.conv2d()函数中filter参数维度（卷积核宽，卷积核高，输入通道，输出通道）与输入的批量图像维度（批量大小，图像宽，图像高，图像通道数）之间的关系：暂且先不考虑图像批量，假设批量大小为1,对于三通道的rgb图像而言，filter的第三维度大小应该为3，即对于rgb每一通道都对应一个卷积核，但最后三个通道卷积的结果需要加和形成一个输出通道。</p>]]></content>
      
      
      <categories>
          
          <category> tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2019/01/20/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/20/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="git-安装与配置"><a href="#git-安装与配置" class="headerlink" title="git 安装与配置"></a>git 安装与配置</h2><p>Ubuntu16.04自带git，无需安装。</p><p>git命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"your name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your email"</span></span><br></pre></td></tr></table></figure><p>设置使用git的用户名和邮箱</p><p>git config命令会在用户的～/.gitconfig文件里写入配置信息。–global表示全局设置。</p><p>将git配置里的color.ui设置成auto可以增加git命令输出的可读性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --gloabl color.ui auto</span><br></pre></td></tr></table></figure><h2 id="git仓库管理原理示意图"><a href="#git仓库管理原理示意图" class="headerlink" title="git仓库管理原理示意图"></a>git仓库管理原理示意图</h2><p><img src="/assets/git_repository.jpg" alt="git示意图"></p><blockquote><p>理解:</p><p>工作区(即工作树)是指你在git仓库的文件目录.git是通过记录修改来进行版本管理的.</p><p>当你在工作区修改或编辑文件后,此时git status返回的提示是’’Changes not staged for commit:”;提示工作区有改动未被添加到暂存区.</p><p>工作区中修改的文件通过git add 命令添加到版本库的暂存区(stage);此时git status返回的提示为”Changes to be committed:”提示更改将要提交.</p><p>git commit 命令将stage里的内容一次性提交到当前分支上去.</p></blockquote><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h4 id="git-init-—-初始化"><a href="#git-init-—-初始化" class="headerlink" title="git init —- 初始化"></a>git init —- 初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir gittest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gittest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="此时便会在当前目录下-工作区-创建一个-git文件-这个文件就是用来管理git仓库的"><a href="#此时便会在当前目录下-工作区-创建一个-git文件-这个文件就是用来管理git仓库的" class="headerlink" title="此时便会在当前目录下(工作区)创建一个.git文件,这个文件就是用来管理git仓库的."></a>此时便会在当前目录下(工作区)创建一个.git文件,这个文件就是用来管理git仓库的.</h4></blockquote><h4 id="git-add-—-添加文件-修改-到版本库的stage-暂存区"><a href="#git-add-—-添加文件-修改-到版本库的stage-暂存区" class="headerlink" title="git add —-添加文件(修改)到版本库的stage(暂存区)"></a>git add —-添加文件(修改)到版本库的stage(暂存区)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt<span class="comment">#添加文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add static/<span class="comment">#添加文件夹(目录)</span></span></span><br></pre></td></tr></table></figure><h4 id="git-commit-m-—-提交-保存仓库的历史记录"><a href="#git-commit-m-—-提交-保存仓库的历史记录" class="headerlink" title="git commit -m \  —-提交, 保存仓库的历史记录"></a>git commit -m \<message>  —-提交, 保存仓库的历史记录</message></h4><blockquote><p>-m  <message>  表示此次提交的概述,方便今后查看管理</message></p></blockquote><h4 id="git-status-—-查看当前状态"><a href="#git-status-—-查看当前状态" class="headerlink" title="git status —- 查看当前状态"></a>git status —- 查看当前状态</h4><h4 id="git-log-—-查看提交的历史记录"><a href="#git-log-—-查看提交的历史记录" class="headerlink" title="git log -  —- 查看提交的历史记录"></a>git log -  —- 查看提交的历史记录</h4><blockquote><p>参数: –pretty=short/oneline显示简略信息</p></blockquote><h4 id="git-diff-—-查看区别对比"><a href="#git-diff-—-查看区别对比" class="headerlink" title="git diff  —-查看区别对比"></a>git diff  —-查看区别对比</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff      <span class="comment"># 查看工作树和暂存区的差别</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD <span class="comment"># 查看工作树和最新提交的差别</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注: HEAD是指向当前分支中最新一次提交的指针.</p><p>工作树就是git仓库当前文件目录下的工作区.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorBoard可视化工具</title>
      <link href="/2019/01/20/TensorBoard%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/01/20/TensorBoard%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol><li><p><strong>名字作用域</strong></p><blockquote><p>名字作用域对于 <strong>计算节点</strong>  <strong>存储节点</strong>  <strong>数据节点</strong> 都有效. 同一名字作用域下的所有节点继承相同的名字前缀, 在数据流图上体现为该作用域下的所有节点汇聚成同一 <strong>抽象节点</strong>.</p></blockquote></li><li><p><strong>变量作用域</strong></p><blockquote><p>只对与存储参数的存储节点 ( 变量 ) 起作用.</p></blockquote></li></ol><h3 id="TensorBoard使用流程"><a href="#TensorBoard使用流程" class="headerlink" title="TensorBoard使用流程"></a>TensorBoard使用流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A1[Summary Ops]--&gt;|Session.run| B[Session]</span><br><span class="line">A2[Graph]--&gt;|session.graph| B</span><br><span class="line">B--&gt;|input| C[FileWrite]</span><br><span class="line">C--&gt;|add| D[Event file]</span><br><span class="line">D--&gt;|load| E[TensorBoard]</span><br></pre></td></tr></table></figure><p><strong>TensorBoard的实现形态是一个web程序，其是通过加载结构化数据来实现可视化的。可视化的数据主要包含：</strong></p><ol><li><p>流程图结构</p><blockquote><p>可以在声明FlieWriter实例是将流程图传入事件文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">&gt; writer = tf.summary.FileWriter(<span class="string">"path_to_file"</span>, sess.graph)</span><br><span class="line">&gt; writer.close()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>汇总数据</p><blockquote><p>需要先声明汇总节点，再通过session.run()方法获取各个汇总节点的汇总数据。最后通过tf.summary.FileWrite().add_summary( )操作将汇总数据写入事件文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; ...</span><br><span class="line">&gt; tf.summary.scalar(name=<span class="string">"loss"</span>, loss)</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; tf.summary.histogram(name=<span class="string">"weights"</span>, weights)</span><br><span class="line">&gt; <span class="comment">#假设声明好了汇总节点</span></span><br><span class="line">&gt; <span class="comment">#汇聚说有汇总节点</span></span><br><span class="line">&gt; merger = tf.summary.merger_all()</span><br><span class="line">&gt; <span class="comment">#会话中运行，获取汇总数据并加入事件文件</span></span><br><span class="line">&gt; <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">&gt;     writer = tf.summary.FileWriter(<span class="string">"path"</span>, sess.graph)</span><br><span class="line">&gt;     summary = sess.run(merger)</span><br><span class="line">&gt;     writer.add_summary(summary, i) //一般会加入迭代步数i</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>事件数据</p><blockquote><p>事件数据表示在会话中执行操作时产生的事件信息，包括时间戳、全局步数、会话日志等等。</p></blockquote></li></ol><h3 id="tf-summary类的成员结构"><a href="#tf-summary类的成员结构" class="headerlink" title="tf.summary类的成员结构"></a>tf.summary类的成员结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">S(tf.Summary)--&gt;ops(Summary Ops)</span><br><span class="line">S--&gt;fw(FileWriter)</span><br><span class="line">ops--&gt;audio(audio--添加音频数据汇总节点)</span><br><span class="line">ops--&gt;image(image--添加图片数据汇总节点)</span><br><span class="line">ops--&gt;scalar(scalar--添加标量值的汇总节点 主要是损失值\正确率等评价指标)</span><br><span class="line">ops--&gt;hist(histogram--添加带有统计值的汇总节点 主要是模型参数)</span><br><span class="line">ops--&gt;merge(merger_all--将所有汇总操作汇聚在一起)</span><br><span class="line"></span><br><span class="line">fw--&gt;su(add_summary--添加汇总数据到事件文件)</span><br><span class="line">fw--&gt;ev(add_event--添加事件数据到事件文件)</span><br><span class="line">fw--&gt;gr(add_graph--添加数据流图到事件文件)</span><br><span class="line">fw--&gt;mate(add_run_matedata--添加元数据信息到事件文件)</span><br><span class="line">fw--&gt;sess(add_session_log--添加会话日志到事件文件)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
